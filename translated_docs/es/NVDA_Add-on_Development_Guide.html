<!doctype html>
 <html lang="es">
 <head>
  <title>[//]: # (Enlaces que pueden usarse en cualquier parte del documento)</title>
  <meta charset="utf-8">
  </head>
  <body>
  <header><h1>[//]: # (Enlaces que pueden usarse en cualquier parte del documento)</h1></header>
  <h1 id="guia-de-desarrollo-de-complementos-de-nvda">Guía de Desarrollo de Complementos de NVDA</h1>
<p>Última versión: abril de 2019 para NVDA 2019.1</p>
<hr />
<h1 id="indice"><strong>ÍNDICE</strong></h1>
<p><em>Nota para usuarios de lectores de pantalla</em>: para volver a este índice, usa tu orden del modo exploración para moverte al encabezado de nivel 1 en dirección contraria.</p>
<ul>
<li><a href="#user-content-authors-contributions-and-copyright">Authors, Contributions, and Copyright</a></li>
<li><a href="#user-content-introduction">Introduction</a></li>
<li><a href="#user-content-audience">Audience</a></li>
<li><a href="#user-content-special-note-on-python-version">Special note on Python version</a></li>
<li><a href="#user-content-a-special-note-for-scripters-of-other-screen-readers">A special note for scripters of other screen readers</a></li>
<li><a href="#user-content-a-special-note-about-windows-store-version-of-nvda">A special note about Windows Store version of NVDA</a></li>
<li><a href="#user-content-a-very-important-note-about-migrating-custom-extension-code-to-development-scratchpad">A very important note about migrating custom extension code to development scratchpad</a></li>
<li><a href="#user-content-add-on-basics">Add-on Basics</a></li>
<li><a href="#user-content-what-are-add-ons">What are Add-ons?</a></li>
<li><a href="#user-content-what-are-add-on-modules">What Are Add-on Modules?</a></li>
<li><a href="#user-content-what-are-add-on-packages">What Are Add-on Packages?</a></li>
<li><a href="#user-content-installing-nvda-add-ons">Installing NVDA Add-ons</a></li>
<li><a href="#user-content-setting-up-the-add-on-development-environment">Setting up the add-on development environment</a></li>
<li><a href="#user-content-meet-system-requirements">Meet System requirements</a></li>
<li><a href="#user-content-add-on-development-folder-structure">Add-on Development Folder Structure</a></li>
<li><a href="#user-content-add-on-folder-structure">Add-on folder structure</a></li>
<li><a href="#user-content-packaging-add-ons">Packaging add-ons</a></li>
<li><a href="#user-content-getting-started-hands-on-examples">Getting started: Hands-on examples</a></li>
<li><a href="#user-content-how-add-on-code-is-organized">How add-on code is organized</a></li>
<li><a href="#user-content-running-your-add-on-in-this-example-chapter">Running your add-on in this example chapter</a></li>
<li><a href="#user-content-example-1-hear-a-tone-when-pressing-nvdaa">Example 1: Hear a tone when pressing NVDA+A</a></li>
<li><a href="#user-content-example-1-code-explanation">Example 1 code explanation</a></li>
<li><a href="#user-content-i-dont-understand-those-above-terms">I don't understand those above terms</a></li>
<li><a href="#user-content-example-2-generate-a-tone-when-switching-to-notepad">Example 2: Generate a tone when switching to Notepad</a></li>
<li><a href="#user-content-example-2-code-explanation">Example 2 code explanation</a></li>
<li><a href="#user-content-more-new-terms-please">More new terms please</a></li>
<li><a href="#user-content-a-few-tips-for-beginners">A few tips for beginners</a></li>
<li><a href="#user-content-useful-modules-from-nvda-core">Useful modules from NVDA core</a></li>
<li><a href="#user-content-list-of-useful-nvda-core-modules-and-methods">List of useful NVDA core modules and methods</a></li>
<li><a href="#user-content-example-1-am-i-on-the-right-app-where-the-focus-is-located">Example 1: am I on the right app where the focus is located?</a></li>
<li><a href="#user-content-example-2-display-a-message-in-a-browse-mode-document">Example 2: Display a message in a browse mode document</a></li>
<li><a href="#user-content-example-3-announce-the-automation-id-of-a-uia-object">Example 3: Announce the automation ID of a UIA object</a></li>
<li><a href="#user-content-example-4-send-keystrokes">Example 4: Send keystrokes</a></li>
<li><a href="#user-content-example-5-stop-speech-whenever-screen-content-changes-if-dynamic-content-change-announcement-is-off">Example 5: Stop speech whenever screen content changes if dynamic content change announcement is off</a></li>
<li><a href="#user-content-add-on-module-components-and-development-tips">Add-on module components and development tips</a></li>
<li><a href="#user-content-the-python-console">The Python Console</a></li>
<li><a href="#user-content-working-with-objects-on-screen">Working with objects on screen</a></li>
<li><a href="#user-content-examining-object-hierarchy">Examining object hierarchy</a></li>
<li><a href="#user-content-focus-vs-navigator-object">Focus vs. navigator object</a></li>
<li><a href="#user-content-other-useful-object-related-goodies">Other useful object-related goodies</a></li>
<li><a href="#user-content-example-1-finding-the-value-of-a-slider-in-a-program">Example 1: Finding the value of a slider in a program</a></li>
<li><a href="#user-content-specialist-objects-and-overriding-object-properties-at-runtime">Specialist objects and overriding object properties at runtime</a></li>
<li><a href="#user-content-examples-of-overlay-classes-and-modified-roles">Examples of overlay classes and modified roles</a></li>
<li><a href="#user-content-input-and-output-scripts-and-ui-messages">Input and output: scripts and UI messages</a></li>
<li><a href="#user-content-example-2-a-basic-script-dictionary-and-message-output">Example 2: A basic script dictionary and message output</a></li>
<li><a href="#user-content-example-3-scripts-for-specific-objects">Example 3: Scripts for specific objects</a></li>
<li><a href="#user-content-script-lookup-order-and-command-conflicts">Script lookup order and command conflicts</a></li>
<li><a href="#user-content-a-few-other-remarks-on-scripts">A few other remarks on scripts</a></li>
<li><a href="#user-content-events">Events</a></li>
<li><a href="#user-content-example-4-announcing-the-changed-name-of-a-control">Example 4: Announcing the changed name of a control</a></li>
<li><a href="#user-content-list-of-possible-events">List of possible events</a></li>
<li><a href="#user-content-events-within-objects">Events within objects</a></li>
<li><a href="#user-content-other-components">Other components</a></li>
<li><a href="#user-content-lets-build-an-add-on">Let's build an add-on</a></li>
<li><a href="#user-content-add-on-planning-and-development-tips">Add-on planning and development tips</a></li>
<li><a href="#user-content-dos-and-donts">Do's and don'ts</a></li>
<li><a href="#user-content-frequently-asked-questions-about-add-on-components-and-development">Frequently Asked Questions about add-on components and development</a></li>
<li><a href="#user-content-introduction-to-global-plugins">Introduction to global plugins</a></li>
<li><a href="#user-content-typical-development-plan-for-global-plugins">Typical development plan for global plugins</a></li>
<li><a href="#user-content-the-global-plugin-code">The global plugin code</a></li>
<li><a href="#user-content-when-to-write-or-not-write-global-plugins">When to write or not write global plugins</a></li>
<li><a href="#user-content-few-more-things-to-remember-about-global-plugins">Few more things to remember about global plugins</a></li>
<li><a href="#user-content-example-1-writing-computer-braille-using-qwerty-keyboard">Example 1: Writing computer braille using QWERTY keyboard</a></li>
<li><a href="#user-content-exercises">Exercises</a></li>
<li><a href="#user-content-introduction-to-app-modules">Introduction to app modules</a></li>
<li><a href="#user-content-differences-between-app-modules-and-global-plugins">Differences between app modules and global plugins</a></li>
<li><a href="#user-content-app-module-development-process-and-strategies">App module development process and strategies</a></li>
<li><a href="#user-content-example-2-simple-app-module-in-notepad">Example 2: Simple app module in Notepad</a></li>
<li><a href="#user-content-example-3-silencing-nvda-in-openbook">Example 3: Silencing NVDA in Openbook</a></li>
<li><a href="#user-content-example-4-announcing-control-property-changes-while-using-another-app">Example 4: Announcing control property changes while using another app</a></li>
<li><a href="#user-content-useful-app-module-properties-and-methods">Useful app module properties and methods</a></li>
<li><a href="#user-content-other-remarks-on-app-modules">Other remarks on app modules</a></li>
<li><a href="#user-content-drivers">Drivers</a></li>
<li><a href="#user-content-driver-components">Driver components</a></li>
<li><a href="#user-content-few-important-things-to-remember-before-during-and-after-driver-development">Few important things to remember before, during and after driver development</a></li>
<li><a href="#user-content-typical-driver-development-steps">Typical driver development steps</a></li>
<li><a href="#user-content-sharing-your-add-on-and-experience-with-others">Sharing your add-on and experience with others</a></li>
<li><a href="#user-content-the-nvda-add-ons-list">The NVDA Add-ons list</a></li>
<li><a href="#user-content-the-nvda-community-add-ons-web-site-and-code-repository">The NVDA Community Add-ons web site and code repository</a></li>
<li><a href="#user-content-miscellaneous-information">Miscellaneous information</a></li>
<li><a href="#user-content-appendicies">Appendicies</a></li>
<li><a href="#user-content-appendix-a-add-on-terms-dictionary">Appendix A: add-on terms dictionary</a></li>
<li><a href="#user-content-appendix-b-programming-and-python-concepts-every-add-on-developer-needs-to-know">Appendix B: Programming and Python concepts every add-on developer needs to know</a></li>
<li><a href="#user-content-appendix-c-add-on-type-comparison">Appendix C: Add-on type comparison</a></li>
<li><a href="#user-content-appendix-d-notes-and-references-for-scripters-of-other-screen-readers">Appendix D: notes and references for scripters of other screen readers</a></li>
</ul>
<hr />
<h2 id="autores-colaboraciones-y-copyright">Autores, Colaboraciones y Copyright</h2>
<p>Esta guía fue escrita originalmente por Joseph Lee, y está diseñada por la comunidad de usuarios y de desarrolladores de NVDA. Agradecemos vuestros comentarios y contribuciones.</p>
<p>NVDA es copyright 2006-2019 NV Access Limited. Microsoft Windows, Microsoft Office, Win32 API y otros productos de Microsoft son propiedad de Microsoft Corporation. el paquete IAccessible es propiedad intelectual de IBM y la Fundación Linux. Python es propiedad intelectual de la Python Software Foundation. Otros productos mencionados son propiedad intelectual de sus respectivos propietarios.</p>
<h2 id="introduccion">Introducción</h2>
<p>Bienvenido a la Guía de desarrollo de complementos para NVDA. Esta es la guía completa sobre cómo desarrollar complementos de NVDA. Esta guía también explica algún segmento de código útil del código fuente del núcleo de NVDA, que resalta conceptos para ti mientras aprendes a escribir complementos.</p>
<p>For more information on NVDA development, please visit the <a href="https://github.com/nvaccess/nvda">NVDA GitHub page</a>. Be sure to go over the <a href="https://www.nvaccess.org/files/nvda/documentation/developerGuide.html">NVDA Developer Guide</a> to familiarize yourself with key terms and basics on getting started with add-on development.</p>
<h2 id="audiencia">Audiencia</h2>
<p>Esta guía se ha diseñado para: </p>
<ul>
<li>aprendices de Python</li>
<li>principiantes en el desarrollo de NVDA</li>
<li>desarrolladores Expertos de Python</li>
<li>desarrolladores Expertos de NVDA</li>
<li>Gente familiarizada con otros lenguajes de programación distintos a Python.</li>
<li>Desarrolladores de scripts para otros lectores de pantalla.</li>
</ul>
<p>If you are new to NVDA add-on or core development, we recommend that you get to know <a href="https://python.org">Python</a> first, as it gives the necessary programming background for understanding the rest of the guide. If you are a Python programmer but new to NVDA development, please checkout the <a href="https://www.nvaccess.org/files/nvda/documentation/developerGuide.html">NVDA Developer Guide</a> and <a href="https://github.com/nvaccess/nvda/wiki/DesignOverview">Design Overview</a> document.</p>
<h3 id="nota-especial-sobre-la-version-de-python">Nota especial sobre la versión de Python</h3>
<p>NVDA y los complementos están escritos en Python 2, específicamente 2.7. Existe un proyecto de investigación activo para transferir NVDA a python 3, con algunos desarrolladores de complementos modificando su código fuente para que se ejecute en Python 2 y 3. Asegúrate de estar atento al desarrollo de NVDA y a las listas de correo de complementos, así como a la documentación de desarrollo relevante y a los avisos relacionados con las noticias sobre Python 3 y NVDA.</p>
<h3 id="una-nota-especial-para-creadores-de-scripts-de-otros-lectores-de-pantalla">Una nota especial para creadores de scripts de otros lectores de pantalla</h3>
<p>Some of the concepts described in this document are the same across different screen readers, such as objects, windows, events, accessibility API and so on. However, there are important things to be aware of when writing or porting scripts:</p>
<ul>
<li>A diferencia de algunos lectores de pantalla, NVDA no tiene una especificación formal o un modelo de objeto definido por la documentación en otros lectores de pantalla.</li>
<li>El código que escribas se ejecutará dentro del mismo entorno de ejecución que el propio lector de pantalla, por lo que puedes realizar cosas como obtener directamente objetos enfocados, modificar la funcionalidad de NVDA e incluso reemplazar las funciones y clases de NVDA con las tuyas propias.</li>
<li>Python, y consecuentemente NVDA, es un sistema orientado a objetos. En otras palabras, la mayor parte de su código consistirá en definir clases y objetos que NVDA recogerá en tiempo de ejecución.</li>
<li>A diferencia de los motores de scripting para algunos lectores de pantalla, no hay ningún hack especial involucrado cuando se desee proporcionar una característica que funcione en todas las aplicaciones.</li>
<li>Unlike scripting engines for some screen readers, you are not limited to libraries that come with screen readers; as a Python-based program, you can use any python module(s) that fits your needs. For example, a popular module used to interface with web applications is JSON (JavaScript Object Notation) module, which isn't bundled with NVDA versions prior to 2017.3. You need to bundle external Python libraries yourself.</li>
</ul>
<h3 id="nota-especial-sobre-la-version-de-nvda-para-la-tienda-de-windows">Nota especial sobre la versión de NVDA para la tienda de Windows</h3>
<p>As of NVDA 2018.1, foundation has been laid to let NVDA run as a Windows Store application. Once the Windows Store version of NVDA is published to Microsoft Store, users running Windows 10 can go to Store and obtain NVDA. However, there are restrictions that come with this version of NVDA, notably add-ons cannot run in this environment. Thus, if you need to run or write NVDA add-ons, you need to use the classic desktop version of NVDA, available from the <a href="https://www.nvaccess.org/">nvaccess.org website</a>.</p>
<h3 id="nota-muy-importante-sobre-la-migracion-de-codigo-personalizado-de-extension-a-development-scratchpad">Nota muy importante sobre la migración de código personalizado de extensión a development scratchpad</h3>
<p>If you are coming from NVDA 2018.4 or earlier, you may recall that you are able to run extension modules inside folders stored in the user configuration directory (e.g. appModules). This functionality has been revised in NVDA 2019.1 as follows:</p>
<ol>
<li>NVDA will no longer load extension code stored in the following subdirectories of the user configuration folder: appModules, brailleDisplayDrivers, globalPlugins, synthDrivers.<ul>
<li>If you find that code inside these folders is no longer working as of NVDA 2019.1, the above reason is why.</li>
</ul>
</li>
<li>Debes activar la funcionalidad development scratchpad (reservada para desarrolladores) si quieres habilitar la carga de código de extensión personalizado. Para hacerlo:<ol>
<li>With NVDA 2019.1 (or later) running, go to NVDA menu/Preferences/settings/Advanced.</li>
<li>You must check "I understand that changing these settings may cause NVDA to function incorrectly".</li>
<li>Debes marcar la casilla "Habilitar la carga de código personalizado desde el directorio Developer Scratchpad".</li>
<li>Pulsa Aceptar.</li>
</ol>
</li>
<li>You must store code that was formerly housed in the above list of subdirectories inside corresponding subdirectories of the scratchpad folder.</li>
<li>If you need to use NVDA 2018.4 and would like to use custom code, you must not remove the above listed subdirectories from the user configuration directory. Otherwise go ahead and remove the folders listed in item 1.</li>
</ol>
<h2 id="add-on-basics">Add-on Basics</h2>
<h3 id="what-are-add-ons">What are Add-ons?</h3>
<p>Add-ons are additional small programs that extend NVDA's functionality or support for applications. This may include adding global features, enhancing 
support for an application, or adding support for newer braille displays or speech synthesizers.</p>
<p>Note: add-ons are sometimes called "Plugins", especially in the <a href="https://www.nvaccess.org/files/nvda/documentation/developerGuide.html">NVDA Developer Guide</a>. In general, we will call them add-ons in this guide for the sake of clarity, but just be aware that they are the same thing.</p>
<p>A fully constructed add-on will consist of the add-on Python code itself, contained in one or more modules (more on that in the next section), and 
usually some documentation, and other support files. If that sounds daunting: don't worry, we will start small, with examples, and only with Python 
code. The rest of the support structure for an add-on will come later.</p>
<h3 id="what-are-add-on-modules">What Are Add-on Modules?</h3>
<p>Add-ons can act globally (across all of NVDA), in a specific application or program, or behind the scenes (at the hardware level). We call these three 
major areas "modules". Every add-on contains at least one module, which is just one or more Python files designed to act in one of those three specific 
areas. Additionally, if it makes sense for the add-on you are developing, your add-on can include more than one module. For example, if your add-on 
provides better accessibility for a specific application, but also provides global commands that work anywhere in NVDA, you would be using two modules.</p>
<p>Actualmente, NVDA soporta estos tipos de módulos adicionales:</p>
<ul>
<li>Extensión global: una extensión global añade características para NVDA que se pueden utilizar en cualquier lugar, como la función de OCR.</li>
<li>Módulo de aplicación: Un módulo de aplicación permite un soporte mejorado para un programa específico. Los módulos de aplicación sólo se ejecutan mientras el programa se ejecute. Cambian la forma en que NVDA reacciona a las ventanas y controles de la aplicación en ejecución. </li>
<li>Controlador: Un controlador permite a un programa comunicarse con el hardware. Actualmente puedes escribir controladores para nuevas pantallas braille o sintetizadores de voz.</li>
</ul>
<h3 id="what-are-add-on-packages">What Are Add-on Packages?</h3>
<p>A package is the single file which contains the code, documentation, and other elements which make up a fully functioning add-on, which is 
intended to be robust enough to be distributed to the public. Each NVDA add-on package is a normal zip file with a file extension of .nvda-addon instead of .zip.</p>
<p>If making an add-on package sounds like a lot of work: don't worry, you don't have to make a package just to start writing and testing your first 
add-on.</p>
<h3 id="instalacion-de-complementos-de-nvda">Instalación de Complementos de NVDA</h3>
<p>You can install NVDA-approved add-on packages via the Add-ons Manager, found on NVDA's tools menu. Alternatively, you can open any .nvda-addon file 
you may have created or downloaded, by selecting it in your Windows file manager, and it should launch the add-on install process.</p>
<h2 id="setting-up-your-add-on-development-environment">Setting Up Your Add-on Development Environment</h2>
<p>Sigue estos pasos para preparar tu ordenador para escribir complementos de NVDA.</p>
<h3 id="meet-system-requirements">Meet System Requirements</h3>
<p>Para crear un complemento para NVDA, asegúrate de que tu sistema cumple los siguientes requisitos:</p>
<ul>
<li>NVDA:</li>
<li>A version of NVDA is available on your computer (either a portable or installed version will work, but we strongly recommend that you install a copy of NVDA on your development computer). Download NVDA from the <a href="https://www.nvaccess.org/download/">NV Access download page</a>.</li>
<li>Even better: we recommend installing the latest master development version to keep up to date with core API changes. You can download the latest snapshots at https://community.nvda-project.org/wiki/Snapshots.</li>
<li>Python:</li>
<li>Python 2.7 series, version 2.7.14 32-bit for Windows: https://www.python.org/downloads/release/python-2714/</li>
<li>If you wish to work with Python 3, use Python 3.7.3, 32-bit for Windows: https://www.python.org/downloads/release/python-373/</li>
<li>SCons 2 or 3, version 2.3.0 or later for generating add-on packages (if using a 3.x release, use 3.0.1 or later): http://www.scons.org/</li>
<li>Markdown 2.0.1 or later for generating add-on documentation: https://pypi.python.org/pypi/Markdown/2.0.1</li>
<li>The GNU Gettext package for Windows for message localization support. The build can be found at: http://gnuwin32.sourceforge.net/downlinks/gettext.php<ul>
<li>Once downloaded, copy both exe files to your add-on development folder. See the next section for a description of the add-on folder structure.</li>
</ul>
</li>
<li>Si estás desarrollando soporte para un programa, sintetizador de voz o pantalla braille, instala el software y el hardware necesario.</li>
<li>Optional Items:</li>
<li>Git 1.7.9 or later if you wish to upload the add-on to a repository such as <a href="https://bitbucket.org/">Bitbucket</a> or <a href="https://www.github.com/">Github</a> (optional. See below). You can use various Git clients, such as <a href="https://www.atlassian.com/git/tutorials/git-bash">Git Bash</a>, [Cygwin's Git][Git for Cygwin], and <a href="https://tortoisegit.org/">TortoiseGit</a>.</li>
<li>The <a href="https://bitbucket.org/nvdaaddonteam/addontemplate/get/master.zip">NVDA Community Add-on Template</a> for ease of add-on file and folder packaging and management (optional).</li>
</ul>
<p>Note: if using Windows 10 Anniversary Update or later and wish to use Ubuntu on Windows (AKA <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" title="Windows Subsystem for Linux">Windows Subsystem for Linux</a>), you can use Advanced Packaging Tool (APT) to obtain SCons and Gettext. You can then use pip to download and install Markdown.</p>
<h3 id="estructura-de-carpetas-de-desarrollo-del-complemento">Estructura de Carpetas de Desarrollo del Complemento</h3>
<p>Cuando escribas complementos, se recomienda que guardes el código del complemento en carpetas separadas, una por complemento. Si decides descargar la plantilla del complemento, la estructura de carpetas se creará automáticamente.</p>
<p>Una vez que instales las dependencias necesarias (mira arriba), pega los ejecutables del paquete Gettext en la carpeta del complemento.</p>
<h3 id="estructura-de-carpetas-del-complemento">Estructura de carpetas del complemento</h3>
<p>Cada carpeta de complementos, como mínimo, debe contener los siguientes archivos y carpetas:</p>
<ul>
<li>manifest.ini para almacenar la información de manifiesto del complemento tal como el nombre, el autor y el rango de compatibilidad (versión mínima, última versión probada).</li>
<li>Una subcarpeta "addon" con el directorio de módulos del complemento bajo esta subcarpeta (appModules, globalPlugins, synthDrivers, brailleDisplays). Se pueden especificar una o más carpetas de módulos.</li>
</ul>
<p>Si estás utilizando la plantilla de complementos, la estructura de carpetas se creará automáticamente, por lo que sólo necesitas crear la subcarpeta addon y las carpetas de módulos adicionales y el código dentro de estas carpetas. Consulta el archivo readme en la carpeta de la plantilla para obtener más información sobre cómo personalizar tu manifiesto de complemento mediante los archivos de la plantilla.</p>
<h3 id="enpaquetado-de-complementos">Enpaquetado de complementos</h3>
<p>Hay dos modos de empaquetar complementos:</p>
<ol>
<li>Para empaquetar el complemento manualmente, comprime (en zip) la carpeta del complemento como un archivo .zip, y luego cambia el nombre de la extensión del archivo a .nvda-addon.</li>
<li>Para utilizar la plantilla de complemento con SCons, abre el símbolo del sistema en el modo Administrador (Windows Vista o posterior) o Bash en Ubuntu en Windows (Windows 10 Anniversary Update con el WSL habilitado), cambie a la carpeta de complemento y escribe `scons~.</li>
</ol>
<p>Para más información sobre gestión de complementos, consulta el capítulo gestión en esta guía.</p>
<h2 id="comenzando-ejemplos-practicos">Comenzando: Ejemplos prácticos</h2>
<p>Entonces, ¿estás listo para comenzar tu aventura con los complementos, pero no estás seguro de cómo darle vida? Si ese es tu caso, vé por favor a través de este capítulo, pues te da la información básica para conseguir comenzar con los complementos y te da consejos para escribir código.</p>
<p>Nota: para este capítulo, no usaremos paquetes de complementos reales. En su lugar, usaremos carpetas de extensiones de scratchpad - una serie de subdirectorios situados en una carpeta llamada "scratchpad", que es una subcarpeta en tu carpeta de configuración de usuario de NVDA (disponible desde el menú de inicio/pantalla si está instalado NVDA) para almacenar nuestros ficheros Python de ejemplo.</p>
<p>Para editar archivos .py, necesitas un procesador de textos que pueda manejar archivos .py. El mejor que recomendamos es Notepad++.</p>
<h3 id="como-esta-organizado-el-codigo-de-los-complementos">Cómo está organizado el código de los complementos</h3>
<p>El código de tu complemento se almacena en uno o más ficheros Python (fichero .py). A pesar de los diferentes tipos de complementos que hay por ahí, todos ellos tienen un diseño similar.</p>
<p>Primero, comienza por escribir una cabecera opcional para el complemento, tal como tu nombre, una o dos frases breves sobre para qué es el complemento y así sucesivamente. Aunque esto es opcional, Se recomienda que escribas el encabezado como un recordatorio para realizar un seguimiento de lo que estás haciendo con tu complemento.</p>
<p>A continuación, le dices a NVDA los módulos que necesitas para el complemento en el archivo. Esto se hace escribiendo <code>import module</code> donde module es el nombre del módulo que desees utilizar en tu código. Por ejemplo, si quieres escuchar tonos mientras escribes tu complemento, escribe <code>import tones</code>. Normalmente será posible que tengas que importar dos o más módulos para tu complemento específico(véase más abajo en la lista de módulos que necesitas para el tipo de módulo del complemento que estés escribiendo).</p>
<p>después de declarar los módulos necesarios o de importar, escribe el código de tu complemento (definiendo clases, variables, métodos y así sucesivamente). La sección más importante es el código de la clase del complemento, que determinará el tipo de módulo de complemento al que se asignará tu código.</p>
<p>Por ejemplo, si deseas agregar soporte para un programa, después de importar appModuleHandler y otros módulos necesarios, podrías escribir:</p>
<p><code>class appModule(appModuleHandler.AppModule):</code></p>
<p>Después de eso, todo lo que se escribe es código Python (consulta la documentación de Python sobre cómo escribir programas en Python).</p>
<h3 id="ejecutar-tu-complemento-de-ejemplo-en-este-capitulo">Ejecutar tu complemento de ejemplo en este capítulo</h3>
<p>Antes de que puedas ejecutar complementos de prueba, debes habilitar el development scratchpad desde las opciones avanzadas de NVDA. Después de hacerlo, aparecerá una nueva carpeta llamada "scratchpad" en la carpeta de configuración del usuario. Lee la sección anterior sobre scratchpad para más detalles sobre cómo hacerlo.</p>
<p>Para ejecutar tu complemento de ejemplo desde este capítulo, abre el directorio de configuración de usuario de NVDA(desde Menú o pantalla Inicio, busca el elemento NVDA "  Explorar carpeta de configuración del usuario"). Luego busca la carpeta "scratchpad" (si está activada), y pega tu fichero .py en la carpeta correspondiente dentro de esta subcarpeta: carpeta appModules para ejemplos de módulos de aplicación, y carpeta globalPlugins para extensiones globales.</p>
<h3 id="ejemplo-1-escuchar-un-tono-al-pulsar-nvdaa">Ejemplo 1: escuchar un tono al pulsar NVDA+A</h3>
<p>Let us start with a simple example: if you press NVDA+A, you will hear a tone for 1 second in any program. Since we want to use this everywhere, it must be a global plugin.</p>
<p>First, if you haven't done so, enable development scratchpad. Then open your user configuration folder, then open the scratchpad folder (if it exists--create it if not), then select globalPlugins folder. Create a new .py file and give it a descriptive name such as example1.py (it is strongly recommended that when you name your global plugin file, give it a short descriptive name). Then open the newly created .py file in the word processor.</p>
<p>El código siguiente implementa nuestro ejemplo. Pon esto en tu .py exactamente como se muestra.:</p>
<pre><code># Primer ejemplo de desarrollo de complemento

import globalPluginHandler
import tones # Queremos escuchar pitidos.

class GlobalPlugin(globalPluginHandler.GlobalPlugin):

    def script_doBeep(self, gesture):
        tones.beep(440, 1000) # pita un Lá estándar de la quinta octava durante 1 segundo.

    __gestures={
        "kb:NVDA+A":"doBeep"
    }
</code></pre>
<p>En Python, para poner comentarios se pone el símbolo número (#) al principio de la línea de comentario.</p>
<h3 id="explicacion-del-codigo-del-ejemplo-1">Explicación del código del ejemplo 1</h3>
<p>Nuestro primer ejemplo nos permite hacer sonar un pitido durante un segundo cuando pulsemos NVDA+A. pero podrías preguntarte sobre el significado del código de más arriba, así que vamos a dar unos pasos a través del código, uno por vez.</p>
<ol>
<li>En la parte superior del archivo, escribimos una cabecera que nos dice que este es un ejemplo de complemento.</li>
<li>Dado que esta es una extensión global, tenemos que importar un módulo fundamental: global plugin handler, por lo que escribimos<code>import globalPluginHandler</code>.</li>
<li>Entonces escribimos<code>import tones</code> para importar (cargar, o incluir) el módulo de tonos, un módulo integrado de NVDA. Cada vez que desees utilizar un método de un módulo dado, importa el o los módulos necesarios.</li>
<li>A continuación, definimos una clase llamada GlobalPlugin. El texto dentro de los paréntesis nos dice de dónde proviene esta clase (más sobre este concepto en un segundo). Una  clase, en programación, describe un objeto, tal como una persona, un escritorio, un programa y otros.</li>
<li>Dentro de la clase, escribimos un método (función) llamado <code>script_doBeep</code>. Esto es un ejemplo de un script, un método que va a ejecutarse al pulsar una orden. Dentro de este script, escribimos <code>tones.beep(440, 1000)</code> para decir a NVDA que haga sonar un tono durante 1 segundo. En programación, una funcción puede tomar argumentos, o un conjunto de parámetros que dice a la función qué hacer basándose en los valores dados(nos los encontraremos más adelante). De hecho, muchos métodos que escribirás, incluyendo nuestro script  doBeep toma uno o más argumentos. Más sobre los scripts más tarde en el viaje a través de la guía.</li>
<li>Por último, escribimos un diccionario simple (una colección) para almacenar enlaces a nuestra orden (script) para nuestro script doBeep. Aquí, le dijimos a NVDA que asignase NVDA+A command para el script doBeep.</li>
</ol>
<p>Guarda este fichero, después reinicia NVDA. Ahora, cada vez que se pulse NVDA+A, se escucha un tono durante 1 segundo. Una vez que te sientas cómodo con el código del complemento y de cómo se presenta, Puedes eliminar el fichero .py recién creado.</p>
<h3 id="no-entiendo-los-terminos-anteriores">No entiendo los términos anteriores</h3>
<p>Para algunos, los términos "clase", "método" y demás podrían ser nuevos. Vamos a repasar lo que son estos términos, ya que son fundamentales para el desarrollo de complementos:</p>
<p>Clase: una clase describe un objeto. Podría describir cualquier cosa, tal como una persona, una mesa, un complemento de NVDA y otros. Las clases son fundamentales para NVDA y otros programas - de hecho, un buen número de programadores son expertos por conocer las clases.
* Método: un método es un pequeño programa o una rutina que ejecuta un programa para hacer algo, tal como generar tonos, calcular números grandes, cargar complementos de NVDA y así sucesivamente. Algunas personas los llaman "funciones."
* Script: un script es un método que se ejecuta cuando el usuario realiza órdenes tales como pulsar ciertas teclas en un teclado. Por ejemplo, cuando pulsas NVDA+F12, NVDA ejecuta el script dateTime, localizado en uno de los módulos principales de NVDA llamado Global Commands. Un script toma dos argumentos: dónde se debería ejecutar el script (normalmente "self"; lo veremos más adelante) y el gesto para el script (véase más adelante).
* Variable: una variable es algo que puede cambiar, tal como el nombre de una persona, un nombre del complemento de NVDA en ejecución, la versión de NVDA que estás utilizando y así sucesivamente. En un archivo de complemento pueden definirse una o más variables(Por ejemplo, para almacenar constantes comunes, tales como cadenas).
* Módulo: un módulo es una colección de métodos y variables en un fichero. Cuando escribimos complementos, de hecho, estamos escribiendo módulos adicionales que NVDA puede utilizar mientras se está ejecutando.</p>
<p>Hay otros términos que vamos a llegar a conocer en breve.</p>
<h3 id="ejemplo-2-generar-un-tono-cuando-se-cambie-al-bloc-de-notas">Ejemplo 2: generar un tono cuando se cambie al Bloc de notas</h3>
<p>La mayor parte del código de abajo viene de la Guía del desarrollador de NVDA.</p>
<p>NVDA no sólo te permite agregar comandos globales, sino que también permite la escritura de código para mejorar el uso de los programas a través de módulos de aplicación. Un módulo de aplicación es también un archivo Python, excepto que, esta vez, el nombre del archivo .PY Es el nombre del ejecutable de un programa. Por ejemplo, un módulo de aplicación para el Bloc de notas se llamaría notepad.py.</p>
<p>El código de abajo, de la Guía del desarrollador de NVDA, da un pequeño ejemplo de un módulo de aplicación típica: reproducir un pitido corto al cambiar al Bloc de notas. Pon el código de abajo en notepad.py, que a su vez se debe colocar en la carpeta appModules del directorio scratchpad (si está activado) en la carpeta de configuración del usuario con el fin de que se ejecute.</p>
<pre><code># Un ejemplo de módulo de aplicación.

import appModuleHandler
import tones

class AppModule(appModuleHandler.AppModule):

    def event_gainFocus(self, obj, nextHandler):
        tones.beep(256, 200)
        nextHandler()
</code></pre>
<h3 id="explicacion-del-codigo-del-ejemplo-2">Explicación del código del ejemplo 2</h3>
<p>Estamos viendo más código nuevo aquí. Vamos a repasar esto, de nuevo pieza por pieza:</p>
<ol>
<li>A diferencia del primer ejemplo, el módulo fundamental que necesitamos es appModuleHandler.</li>
<li>La clase que estamos utilizando es appModule.</li>
<li>A diferencia de la última vez, estamos utilizando eventos, un método que se ejecuta cuando se producen determinados eventos, como cuando los nombres de los controles cambian. Los eventos reciben un objeto como uno de sus argumentos, el objeto para el que el evento debe ser tratado, o, como mucha gente dice, "disparado."</li>
<li>Dentro del método de evento, también estamos viendo una llamada a<code>nextHandler</code>. Este método se utiliza en métodos de evento para decirle a NVDA que pase el evento para que pueda ser atendido, tal como decir el nombre de un control después de sonar.</li>
</ol>
<h3 id="mas-terminos-nuevos-por-favor">Más términos nuevos por favor</h3>
<p>Otros términos que puedes ver son:</p>
<ul>
<li>Evento: un evento es un método que va a ser ejecutado cuando sucedan algunos hechos, tales como cuando un programa esté enfocado, cuando cambien los nombres de un control y así.</li>
<li>Llamada: decimos que una función llama a algún otro método cuando corremos el segundo método desde otro método. Por ejemplo, en nuestro primer ejemplo, llamábamos al método tones.beep desde nuestro método de script.</li>
<li>Objeto: un objeto es una instancia de una clase- es decir, una clase que se crea cuando se ejecuta un programa. A lo largo de tus complementos, a medida que escribes las clases y al ejecutar tus complementos, tus clases cobran vida como objetos, comúnmente abreviados como obj. En NVDA, un objeto puede referirse a los controles o partes de un programa.</li>
<li>Self: en Python, la palabra"self" significa clase actual(si estamos definiendo una, como por ejemplo al escribir complementos), o significa la clase para la que se define un método. Por ejemplo, en una clase llamada numbers, el método añadido tendría a self como su primer argumento, recordándonos que el método añadido es parte de la clase numbers. En el mundo de desarrollo de NVDA, self por lo general significa el objeto actual de NVDA (véase más adelante), o en el desarrollo de complementos, la instancia de un complemento. Muchos de tus métodos tendrán a self como el primer argumento.</li>
</ul>
<p>Al igual que en el ejemplo 1, una vez te sientas cómodo con el código del módulo de aplicación, es posible que desees eliminar este código para el Bloc de notas,  a menos que desees mantener el oír pitidos cuando se cambie al Bloc de notas. Las diferencias reales entre extensiones globales y módulos de aplicación se harán más claras cuando hablemos de ellos con más detalle en esta guía.</p>
<h3 id="algunos-consejos-para-principiantes">Algunos consejos para principiantes</h3>
<p>Aquí van algunos consejos útiles transmitidos por escritores de complementos:</p>
<ul>
<li>Comienza con complementos sencillos, como decir un mensaje, tonos, etc.</li>
<li>Escribe y prueba un método por vez.</li>
<li>Si estás escribiendo módulos de aplicación o controladores, familiarízate con los programas, sintetizadores o pantallas braille a las que desees dar soporte (por ejemplo lee la documentación, trata de usarlos, etc.).</li>
<li>En la definición de las órdenes (especialmente en extensiones globales), primero consulta las órdenes utilizadas en NVDA y otros complementos antes de asignar una nueva orden en el complemento para evitar conflictos de órdenes.</li>
</ul>
<h2 id="modulos-utiles-del-nucleo-de-nvda">Módulos útiles del núcleo de NVDA</h2>
<p>A lo largo de la vida del desarrollo de un complemento, te encontrarás con algunos módulos útiles del núcleo de NVDA que serían útiles en el código para tu complemento. Esta sección te los explica y también algunas funciones.</p>
<p>Nota: para lectores que sean creadores de scripts para otros lectores de pantalla, consultad el Apéndice D sobre las funciones equivalentes entre las herramientas de creación de scripts de lectores de pantalla.</p>
<h3 id="lista-de-modulos-y-metodos-basicos-utiles-de-nvda">Lista de módulos y métodos básicos útiles de NVDA</h3>
<p>A continuación se enumeran los módulos disponibles del núcleo de NVDA y algunos métodos útiles que se encuentran en los módulos:</p>
<ul>
<li>Addon Handler (addonHandler.py): El módulo que implementa el subsistema de complementos. El método addonHandler.initTranslation() se utiliza para inicializar el soporte de internacionalización para tu complemento.</li>
<li>API básica de NVDA (api.py): una colección de los métodos básicos utilizados en NVDA, como la obtención del foco y el navegador de objetos, ajustar el foco, etc. Algunas de las funciones más útiles son:<ul>
<li><code>api.getFocusObject()</code>: recupera el control enfocado (devuelve el objeto con el foco).</li>
<li><code>api.getNavigatorObject()</code>: obtiene el navegador de objetos actual. Si NVDA está configurado para seguir al foco del sistema, el foco y el navegador de objetos serán lo mismo, de otro modo se devuelve un objeto diferente.</li>
<li><code>api.getForegroundObject()</code>: devuelve la ventana en primer plano de la aplicación actual (el padre de este objeto es la aplicación misma).</li>
<li>Estos tienen un método correspondiente para establecer un objeto determinado como el foco o el navegador de objetos. Ten en cuenta que esto permite a NVDA consultar el foco o el navegador de objetos nuevo pero no cambia el foco actual del sistema.</li>
<li><code>api.getDesktopObject()</code>: devuelve la shell (objeto del nivel más alto).</li>
<li><code>api.copyToClip()</code>: copia texto en el portapapeles.</li>
</ul>
</li>
<li>Subsistema de módulos de aplicación (appModuleHandler.py, appModules): El subsistema encargado de manejar los módulos de aplicación (véase el capítulo sobre los módulos de aplicación para obtener más información).</li>
<li>Soporte de ARIA (aria.py): implementa el soporte para aplicaciones de Internet enriquecidas accesibles (ARIA).</li>
<li>Colección de objetos base (baseObject.py): contiene objetos base útiles tales como  objetos scriptables (consulta el capítulo sobre objetos de NVDA y superposición de objetos para más información).</li>
<li>Subsistema de entrada y salida braille (braille.py, brailleInput.py): controla la salida y la entrada braille de las pantallas braille, necesario para complementos de controladores de pantallas braille.</li>
<li>Módulos integrados (builtin.py): permite el acceso a módulos integrados cuando se trabaja con complementos.</li>
<li>Configuración (config): gestiona la configuración y los perfiles (los perfiles están disponibles en 2013.3 o posterior).</li>
<li>Colección de controles y estados (controlTypes.py): incluye diccionarios sobre los tipos de control (roles) y posibles estados.</li>
<li>Eventos (eventHandler.py): maneja varios eventos como la optención del foco. Una función en particular es útil en los módulos de aplicación:<ul>
<li><code>eventHandler.requestEvents(process ID, window class name for the control, event to be requested)</code>: Permite a NVDA escuchar eventos específicos para ciertos controles mientras se utiliza otra aplicación.</li>
</ul>
</li>
<li>Puntos de extensión (extensionPoints.py): proporciona una forma de permitir que los complementos y otros módulos definan y respondan a acciones específicas como cambios de perfil, acciones en un complemento, etc. Se definen los siguientes puntos de extensión:<ul>
<li><code>extensionPoints.Action</code>; notifica cuando algo ocurre, por ejemplo: el perfil cambia.</li>
<li><code>extensionPoints.Decider</code>: decide si procesar algo más, por ejemplo: procesar la entrada del teclado desde un sistema remoto.</li>
<li><code>extensionPoints.Filter</code>: modifica un texto determinado para su procesamiento posterior, por ejemplo, secuencias avanzadas de voz.</li>
</ul>
</li>
<li>Colección de Comandos globales (globalCommands.py): Una lista de las órdenes globales disponibles durante el uso de NVDA (véase la sección  sobre el alcance de un script para más información).</li>
<li>Subsistema de extensiones globales (globalPluginHandler.py): El módulo necesario para controlar las extensiones globales.</li>
<li>GUI de NVDA (gui): Una colección de clases utilizadas por NVDA para mostrar sus mensajes de forma gráfica. Incluye la interfaz gráfica de usuario para el menú de NVDA, el administrador de complementos y otros.</li>
<li>Servicios de los puertos Hardware(hwPortUtils.py): Un conjunto de utilidades para la comunicación a través de los puertos serie de hardware y otros, útil durante el desarrollo de un complemento de controlador.</li>
<li>Soporte para IAccessible (IAccessibleHandler.py, objetos IAccessible): Se utiliza para dar soporte a los controles IAccessible.</li>
<li>Gestión de entrada (inputCore.py): Gestiona la entrada del usuario.</li>
<li>Soporte de Java Access Bridge (JABHandler.py): Una colección de los métodos utilizados para soportar el subsistema JAB utilizado por las aplicaciones Java.</li>
<li>Entrada de teclado (keyboardHandler.py): Soporta la introducción de órdenes desde el teclado.</li>
<li>Función de registro (logHandler.py): Permite a un módulo escribir registros para ser vistos por un desarrollador o por un usuario a través del visualizador de registro. Incluye la siguiente clase:<ul>
<li><code>logHandler.Log</code>: la clase que implementa la utilidad de registro.</li>
</ul>
</li>
<li>Presentación de contenido matemático (paquetes de MathPress): permite a NVDA reconocer e interactuar con diversos contenidos matemáticos y lenguajes de marcado. NVDA incluye el paquete de soporte MathML y el soporte para Math Player, que viene incorporado en 2015.2 o posterior.</li>
<li>Soporte de ratón (mouseHandler.py): Soporta órdenes de ratón.</li>
<li>Colección de objetos de NVDA (NVDAObjects): Una colección de objetos o controles de NVDA que se utilizan en muchas aplicaciones y estándares como la UIA (User Interface Automation). Algunos objetos requieren que se realicen acciones especiales y éstas se especifican en el módulo de comportamientos del paquete de objetos NVDA. Entre los más comunes se incluyen:<ul>
<li><code>NVDAObjects.NVDAObject</code>: la clase base para objetos de NVDA donde se definen eventos, propiedades, etcétera.</li>
<li><code>NVDAObjects.IAccessible</code>: una colección de objetos MSAA/IAccessible, tales como la que funciona con vistas de listas SysListView32 y otros.</li>
<li><code>NVDAObjects.JAB</code>: una colección de clases utilizadas al interactuar con aplicaciones Java y Java Access Bridge.</li>
<li><code>NVDAObjects.UIA</code>: varias clases para objetos impulsados por UI Automation. Desde 2016, también es el sitio de una colección de controles usados en Microsoft Edge y objetos promovidos por el motor de renderizado EdgeHTML.</li>
<li><code>NVDAObjects.Window</code>: ventanas genéricas y otros objetos personalizados como los que se encuentran en Microsoft Excel.</li>
<li><code>NVDAObjects.behaviors</code>: una colección de comportamientos para controles específicos, tales como editar campos con o sin detección de selección, terminales, consejos, globos de ayuda, una forma de simular órdenes de tabla en varios controles y otros.</li>
</ul>
</li>
<li>Facilidad de revisión (review.py): ayuda a trabajar con el cursor de revisión.</li>
<li>Soporte de Scripts (scriptHandler.py): Maneja scripts, métodos ejecutados debido a la pulsación de las órdenes de teclado y otras entradas.</li>
<li>Salida de voz(speech.py): Controla la salida de voz.</li>
<li>Soporte para controladores de Sintetizador (synthDriverHandler.py): Este es el módulo principal necesario para complementos de sintetizador de voz.</li>
<li>Acceso al texto de los Widgets (textInfos): Permite el acceso al texto de widgets y documentos.</li>
<li>Soporte de pantalla táctil (touchHandler.py): Proporciona soporte para la entrada de la pantalla táctil (sólo versiones instaladas).<ul>
<li><code>touchHandler.touchSupported()</code> (NVDA 2018.1 o posterior): indica si el sistema soporta interacción táctil.</li>
</ul>
</li>
<li>Salida de tonos (tones.py): Permite al usuario escuchar tonos. Se definió la siguiente función:<ul>
<li><code>tones.beep(tono en hercios, duración en milésimas de segundo, volumen del canal izquierdo, volumen del canal derecho)</code>: Reproduce un sonido de un tono específico durante un tiempo determinado. Los dos primeros argumentos son obligatorios, mientras que los otros dos son opcionales.</li>
</ul>
</li>
<li>Mensajes de la interfaz de usuario (ui.py): Incluye varias funciones para la salida de voz y/o braille, incluyendo:<ul>
<li><code>ui.message(mensaje a ser verbalizado/braillificado)</code>: verbaliza o braillifica el mensaje. Este debe ser una cadena entre comillas.</li>
<li><code>ui.browseableMessage(mensaje a ser mostrado, HTML o no)</code>: muestra algún texto en una ventana de navegador web. Si deseas utilizar el marcado HTML, define el argumento isHTML como True.</li>
</ul>
</li>
<li>Soporte UIA (UIAHandler.py, objetos UIA): Usado para soportar controles UIA (User Interface Automation) (Windows 7 y posteriores).</li>
<li>Mmodos virtuales(virtualBuffers): Maneja documentos del modo virtual, tales como sitios web.</li>
<li>Capas de la API de Windows: los siguientes módulos son capas delgadas de las bibliotecas de la API de Windows. Puedes utilizar los módulos siguientes o llamar a la API de Windows directamente a través de ctypes.windll.dllname (por ejemplo, ctypes.windll.user32):<ul>
<li><code>winKernel</code>: abarca algunas constantes, estructuras y funciones de kernel32.dll que se encuentran comúnmente en NVDA.</li>
<li><code>winUser</code>: abarca las constantes, estructuras y funciones definidas en user32.dll que utiliza NVDA.</li>
</ul>
</li>
</ul>
<p>Los módulos sin extensión .py son directorios que contienen módulos especializados. Hay otros métodos útiles por ahí, además de la lista anterior, pero los anteriores son los más útiles. Consulta la documentación del código fuente de NVDA para ver otros métodos, o mira los ejemplos que aparecen a continuación para ver cómo se utilizan estos métodos y otros durante la vida de un complemento.</p>
<h3 id="ejemplo-1-estoy-en-la-aplicacion-correcta-donde-se-encuentra-el-foco">Ejemplo 1: ¿Estoy en la aplicación correcta donde se encuentra el foco?</h3>
<p>El siguiente código verifica si el navegador de objetos e encuentra en algún lugar de la misma aplicación o no.</p>
<pre><code>import api
import ui

def sameApp(obj=None):
    if obj is None:
        obj = api.getNavigatorObject()
    return api.getFocusObject().appModule == obj.appModule
</code></pre>
<p>La función <code>api.getNavigatorObject ()</code> devuelve el objeto del navegador actual, el objeto que te interesa en lugar del objeto enfocado. Cada objeto de NVDA incluye un miembro <code>appModule</code> que registra en qué aplicación se encuentra un objeto.</p>
<h3 id="example-2-display-a-message-in-a-browse-mode-document">Example 2: Display a message in a browse mode document</h3>
<p>In NVDA 2015.2 and later, it became possible to display a message in a browse mode window so people can use browse mode commands to review the message content. The below code displays "Hello world" in a document window.</p>
<pre><code>import ui

ui.browseableMessage("Hola Mundo!", isHtml=False)
</code></pre>
<p>La bandera isHtml indica a NVDA que trate el mensaje como un texto HTML.</p>
<h3 id="ejemplo-3-anunciar-el-id-de-automatizacion-de-un-objeto-uia">Ejemplo 3: Anunciar el ID de automatización de un objeto UIA</h3>
<p>In UI Automation, automation ID is used to identify different screen elements. The following code displays this information in a browsable window.</p>
<pre><code>import ui
from NVDAObjects.UIA import UIA

def announceUIAId():
    obj = api.getFocusObject()
    if isinstance(obj, UIA):
        UIAElement = obj.UIAElement
        ui.browseableMessage(UIAElement.cachedAutomationId, isHtml=True)
</code></pre>
<h3 id="ejemplo-4-enviar-pulsaciones-de-teclas">Ejemplo 4: Enviar pulsaciones de teclas</h3>
<p>Puedes pedirle a NVDA que envíe pulsaciones de teclas específicas instanciando un objeto de gesto de teclado.</p>
<pre><code>import keyboardHandler

def sendApplicationsKey():
    keyboardHandler.KeyboardInputGesture.fromName("applications").send()
</code></pre>
<h3 id="ejemplo-5-detener-la-voz-cada-vez-que-cambie-el-contenido-de-la-pantalla-si-el-anuncio-de-cambio-de-contenido-dinamico-esta-desactivado">Ejemplo 5: Detener la voz cada vez que cambie el contenido de la pantalla si el anuncio de cambio de contenido dinámico está desactivado</h3>
<p>El código que aparece a continuación es un controlador para un evento de cambio de nombre que detiene la voz siempre que el contenido de la pantalla cambie si el anuncio de cambio de contenido dinámico está desactivado.</p>
<pre><code>import appModuleHandler
import config
import speech

class AppModule(appModuleHandler.AppModule):

    def event_nameChange(self, obj, nextHandler):
        if not config.conf["presentation"]["reportDynamicContentChanges"]:
            speech.cancelSpeech()
</code></pre>
<p>Esto es sólo una muestra de lo que pueden hacer varios módulos y funciones de NVDA en tu complemento. Recorreremos los componentes complementarios y realizaremos más funciones a lo largo de esta guía.</p>
<h2 id="componentes-del-modulo-de-un-complemento-y-consejos-de-desarrollo">Componentes del módulo de un complemento y consejos de desarrollo</h2>
<p>Un módulo de complemento se compone de una serie de componentes. Esto incluye el manejo de la entrada y de la salida, el trabajo con diferentes objetos de NVDA, la reacción a eventos, el almacenamiento de configuración y más.</p>
<p>Este capítulo presenta los componentes y conceptos clave que se utilizan en el desarrollo de complementos, tales como objetos de NVDA, scripts, gestión de eventos y temas adicionales con ejemplos.</p>
<p>Note that the <a href="https://www.nvaccess.org/files/nvda/documentation/developerGuide.html">NVDA core development guide</a> introduces the below concepts. This chapter is intended as an extension of that document. Consult the NVDA developer guide for a brief introduction.</p>
<p>Nota para creadores de scripts de otros lectores de pantalla: es posible que estés familiarizado con algunos de los conceptos introducidos en esta sección. Por favor, lee esta sección si deseas conocer mejor cómo se utilizan algunos de ellos en NVDA.</p>
<h3 id="la-consola-python">La consola Python</h3>
<p>This guide sometimes suggests that you use the <a href="https://www.nvaccess.org/files/nvda/documentation/developerGuide.html#PythonConsole" title="Python Console in NVDA Developer Guide">Python Console</a>. The console is a feature of NVDA which can be very useful to developers. It is described in more detail in chapter 5 of the <a href="https://www.nvaccess.org/files/nvda/documentation/developerGuide.html">NVDA Developer Guide</a>.
Puedes activarla yendo al menú Herramientas de NVDA, o pulsando NVDA+ctrl+z.</p>
<h3 id="trabajando-con-objetos-en-pantalla">Trabajando con objetos en pantalla</h3>
<p>Un objeto es una instancia de una clase - es decir, una clase activa mientras un programa se está ejecutando. Por ejemplo, si se ha definido una clase llamada botón, el botón en una pantalla es el objeto de esta clase botón.</p>
<p>En NVDA, un objeto es la representación de un control o partes de un programa. Esto incluye botones, casillas de verificación, campos de edición, barras de herramientas, deslizadores e incluso la ventana de la aplicación. Estos se organizan en jerarquías, o relación padre-hijo donde un objeto podrá contener objetos hijos - por ejemplo, un objeto lista en Windows Explorer podrá contener uno o más elementos de lista, y el padre de esta lista podría ser la ventana de Windows Explorer. El objeto que estás examinando en este momento se denomina "navegador de objetos."</p>
<p>Los objetos de NVDA (o simplemente llamados objetos) contienen una serie de propiedades o atributos útiles. Estos incluyen el nombre del objeto, su valor (seleccionado, el texto de la ventana de edición, etc), rol (casilla de verificación, ventana, objeto incrustado, etc., posición (coordenadas de la pantalla) y más. Los objetos de NVDA también contienen métodos útiles para su manipulación, tales como cambiar el valor del objeto, reaccionar a los eventos para el objeto (recepción del foco, el valor ha cambiado, etc) y demás.</p>
<p>En muchas situaciones, un objeto NVDA puede pertenecer a una clase de objetos relacionados. Para cada una de las clases de objetos, NVDA proporciona formas de manipularlos. Estas clases incluyen IAccessible, JAB, UIA y así. Estas clases y comportamientos para cada clase de objetos se definen en el directorio NVDAObjects en el código fuente de NVDA, y para utilizarlos en tu complemento, importa el controlador de clase de objeto adecuado para el objeto que estás utilizando(por ejemplo si estás trabajando con un objeto IAccessible, importa NVDAObjects.IAccessible.).</p>
<p>Dos de estas clases de objetos merecen especial mención: los modos virtuales y los interceptores de árbol. Un interceptor de árbol permite a NVDA funcionar con un "árbol" de objetos como si fuesen sólo un objeto. un caso especial de interceptor de árbol es el modo virtual, que permite a NVDA trabajar con documentos complejos, como documentos PDF. Estos objetos contienen un mecanismo especial para determinar si una orden de teclado dada será pasada a la aplicación o manejada por NVDA (por ejemplo, el modo de exploración donde se usa la primera letra de navegación para moverse entre elementos).</p>
<h3 id="examinando-la-jerarquia-de-objetos">Examinando la jerarquía de objetos</h3>
<p>Hay varias alternativas que puedes utilizar para ver la jerarquía de un objeto de un determinado programa:</p>
<ol>
<li>utilizando las órdenes de navegación de objetos(NVDA+2/4/5/6/8 del teclado numérico) con el modo simple de revisión desactivado.</li>
<li>Utilizando la [consola Python], usa los atributos obj.next/previous/parent/firstChild/lastChild. Si quieres ver todas las propiedades disponibles, desde la consola Python , escribe dir(obj).</li>
</ol>
<p>Si deseas ver una descripción más detallada sobre el navegador de objetos, mientras que el navegador de objetos se encuentre en el objeto en que estés interesado, pulsa NVDA+F1 para lanzar el visualizador del registro. La raíz de todos los objetos de Windows es el escritorio, objeto shell.</p>
<h3 id="foco-vs-navegador-de-objetos">Foco vs. navegador de objetos</h3>
<p>En tu complemento, podrías querer trabajar con varios objetos y manipularlos. Esto puede incluír cambiar el objeto enfocado, sincronizar el navegador de objetos y el foco, cambiar la función de un objeto y así sucesivamente.</p>
<p>Un objeto en el foco es el control enfocado actualmente. Este está relacionado con el foco del teclado- es decir, sigue al control resaltado. En contraste, un navegador de objetos es el objeto de tu interés. Dado que el navegador de objetos se puede mover en cualquier lugar, puedes examinar dos objetos a la vez: el objeto enfocado y el navegador de objetos. Por ejemplo, podrías enfocar sobre un campo de edición mientras examinas la barra de título con el navegador de objetos. Ya hemos visto un ejemplo más arriba donde podemos comprobar si estamos en dos aplicaciones diferentes mirando los módulos de aplicación del navegador de objetos y del objeto con el foco.</p>
<p>En tu complemento, para obtener el objeto con el foco, escribe <code>someObj = api.getFocusObject()</code>. el someObj puede ser llamado de forma diferente- la convención es utilizar el nombre "obj". Para obtener el navegador de objetos (que podría ser diferente del del objeto enfocado), utiliza <code>obj = api.getNavigatorObject()</code>.</p>
<h3 id="otras-golosinas-utiles-relacionadas-con-objetos">Otras golosinas útiles relacionadas con objetos</h3>
<p>Aquí van algunos otros métodos que funcionan con objetos de NVDA, todos ubicados en el módulo api.py:</p>
<p>Si deseas obtener el objeto en primer plano (útil si se desea ver algún objeto secundario de la ventana en primer plano), utiliza <code>obj = api.getForegroundObject()</code>.
* Desde la [consola Python], para ver el número de objetos secundarios que contiene un objeto (por ejemplo, el hijo,  o los widgets de una ventana en primer plano), teclea <code>obj.childCount</code>. El valor0 significa que no hay más objetos secundarios.
* Para definir un objeto como el foco nuevo o el navegador de objetos, utiliza <code>api.setFocusObject(obj)</code> o <code>api.setNavigatorObject(obj)</code>. Esto no cambia la forma que tiene Windows de ver el objeto enfocado, simplemente hace creer a NVDA que el nuevo objeto es el que tiene el foco o el navegador de objetos.
* Puedes obtener varias propiedades de un objeto especificando obj.property donde property es el atributo que deseas ver (por ejemplo obj.value). Entre las propiedades más comunes se incluyen name, value, states, role, appModule, windowClassName, etc.</p>
<h3 id="ejemplo-1-encontrar-el-valor-de-un-deslizador-en-un-programa">Ejemplo 1: encontrar el valor de un deslizador en un programa</h3>
<p>Supongamos que un usuario te pide que le des el valor de un deslizador en un programa usando un app module. Después de buscar en la jerarquía de objetos y otras propiedades, sabes que la barra de herramientas es el último hijo del objeto en primer plano.</p>
<p>Aquí está el código para implementar esta función:</p>
<pre><code># Ejemplo de objeto 1

import api
import appModuleHandler

class AppModule(appModuleHandler.AppModule):

    sliderChildIndex = -1 # La variable para almacenar el índice del hijo.

    def getSliderValue(self):
        fg = api.getForegroundObject()
        sliderVal = fg.children[self.sliderChildIndex].value
        return sliderVal
</code></pre>
<p>En este código, el método <code>fg.children[index]</code> se utiliza para recuperar al hijo con el índice dado (aquí, ya dijimos que la barra de herramientas es el último hijo, el índice sería menos 1, o el último hijo; podríamos haber utilizado fg.lastChild). Alternativamente, puedes utilizar `fg.getChild (-1) en ciertas situaciones (IAccesible, por ejemplo).</p>
<p>Sin embargo, este código tiene un problema: ¿y si el valor del deslizador está en realidad dentro del primer elemento secundario del control deslizador real? Una forma de solucionar este problema es comprobar el rol del objeto. El código modificado quedaría así:</p>
<pre><code>def getSliderValue(self):
    from controltypes import ROLE_SLIDER # es posible importar desde dentro de un método.
    fg = api.getForegroundObject()
    slider = fg.lastChild
    if slider.role == ROLE_SLIDER: return slider.firstChild.value
</code></pre>
<p>Así, cuando estemos seguros de que estamos tratando con el control deslizador, el método devuelve el valor del primer hijo del deslizador (Si ese es el caso). Presta atención a los dos signos de igual para la comparación de igualdad, en lugar de sólo uno que es el signo igual para la asignación.</p>
<p>Hay otros ejemplos que puedes probar para familiarizarte con la navegación y manipulación de objetos:</p>
<ul>
<li>Obtener el nombre de un objeto que se encuentre en otro lugar en el programa.</li>
<li>Mover el navegador de objetos al objeto en primer plano.</li>
<li>Poner el foco en otro programa.</li>
<li>Localizar la primera barra de estado en un programa con varias barras de estado.</li>
</ul>
<p>Para ver ejemplos de la vida real sobre los objetos de NVDA, consulta el código fuente de NVDA o los códigos fuente de diversos complementos de la comunidad.</p>
<h3 id="objetos-especiales-y-redefinicion-de-las-propiedades-de-objetos-en-tiempo-de-ejecucion">Objetos Especiales y redefinición de las propiedades de objetos en tiempo de ejecución</h3>
<p>A veces, no es suficiente con trabajar con el comportamiento predeterminado de un control. Por ejemplo, algunas partes de un programa pueden necesitar gestos personalizados, o puede que uno tenga que cambiar el rol de una ventana a la de un botón.</p>
<p>NVDA proporciona dos métodos para crear objetos especiales o superpuestos (o clases), cada uno adaptado para diferentes necesidades:</p>
<ul>
<li><code>event_NVDAObject_init(self, objeto con el que trabajamos)</code>: Si deseas sobreescribir ciertos atributos de un control, como su rol o la etiqueta(nombre), puedes utilizar este método para pedirle a NVDA que tome en cuenta tu"entrada" cuando se encuentran los objetos por primera vez (o inicializados). Por ejemplo, si el control tiene el nombre de clase de ventana TForm (visto en muchas aplicaciones Delphi), puedes pedir a NVDA que trate a este control como una ventana estándar asignando obj.role = ROLE_WINDOW (ver diccionario tipos de control para lista de roles disponibles).</li>
<li><code>chooseNVDAObjectOverlayClasses(self, object, lista de clases)</code>: Esto permite a NVDA que utilice su propia lógica cuando se trate de ciertos objetos. Por ejemplo, esto es útil si deseas asignar gestos personalizados para determinadas partes de un programa en tu módulo de aplicación (De hecho, muchos módulos de aplicación crean objetos para hacer frente a determinadas partes de un programa, luego usan chooseNVDAObjectOverlayClasses para seleccionar el objeto correcto cuando se cumplan ciertas condiciones). Estos objetos personalizados se deben basar en un objeto sólido con el que deseamos trabajar (la mayoría de las veces IAccessible es suficiente, por lo tanto los demás objetos superppuestos heredan de, o son los hijos o clases especializadas de los objetos IAccessible). En ciertas situaciones, puedes deshacerte de una propiedad de un objeto usando este método, por ejemplo diciendo a NVDA que no trate a una barra de progreso como tal, eliminando el comportamiento de barra de progreso del objeto en cuestión.</li>
</ul>
<p>Ten en cuenta que en el caso del segundo método, la clase(s) con el nombre dado debe estar presente en el fichero, que es/son heredados de un objeto base conocido (en Python, la sintaxis para la herencia es <code>claseHija(claseBase)</code>, y es por lo general leída como, "esta clase hija hereda de esta clase base". Veremos un código como éste más tarde).</p>
<h3 id="ejemplos-de-sobreescritura-de-clases-y-de-modificacion-de-roles">Ejemplos de sobreescritura de clases y de modificación de roles</h3>
<p>A continuación los ejemplos que ilustran el uso de los dos métodos de modificación de sobreescritura y de atributos que hemos comentado anteriormente:</p>
<p>Un ejemplo del primer caso: la modificación de un atributo.</p>
<pre><code># Reasignar algunos formularios Delphi como ventana.
from controlTypes import ROLE_WINDOW
def event_NVDAObject_init(self, obj):
    if obj.windowClassName == "TForm": obj.role = ROLE_WINDOW
</code></pre>
<p>Esto significa que cada vez que nos encontremos con una ventana con la clase llamada "TForm", NVDA la tratará como una ventana normal.</p>
<p>El ejemplo 2 trata de un módulo de aplicación que tiene dos objetos para tratar con partes específicas de un programa, luego usa chooseNVDAObjectOverlayClasses para asignar la lógica para cada control.</p>
<pre><code>#Un ejemplo de superposición de clases

class enhancedEdit(IAccessible):
    # Algún código para ejecutarse cuando el nombre de la clase de la ventana es MyEdit.

class MainWindow(IAccessible):
    # Otro código, esta vez añadiendo gestos personalizados para la ventana principal del programa.

# En el módulo de aplicación:

def chooseNVDAObjectOverlayClasses(self, obj, clsList):
    if obj.windowClassName == "myEdit": clsList.insert(0, enhancedEdit)
    elif obj.windowClassName == "TWindow": clsList.insert(0, mainWindow)
</code></pre>
<p>En ambos casos, el objeto que se desea comprobar debe insertarse como el primer elemento de la clsList. El efecto es que estos objetos personalizados tendrán prioridad cuando se estén buscando gestos o código (comportamiento) para el objeto, y en la información del desarrollador, estos objetos personalizados vendrán por primera vez cuando el MRO (orden de Métodos de Resolución) muestre el navegador de objetos.</p>
<p>Nota: es posible que tengas que afinar estos dos métodos para proporcionar clases de superposición correctas para controles muy específicos (tales como comprobación de nombres, roles específicos, etc.); de lo contrario, es posible que descubras que se asignan dos o más controles de apariencia idéntica a tu objeto personalizado cuando en realidad son muy diferentes. Además, el event_NVDAObject_init sólo está disponible en módulos de aplicación.</p>
<h3 id="entrada-y-salida-scripts-y-mensajes-iu">Entrada y salida: scripts y mensajes IU</h3>
<p>Otro  componente crucial de los complementos es manejar órdenes del usuario y mostrar qué está haciendo el complemento. Esto se realiza a través de scripts (en la entrada) y  mensajes IU (en la salida).</p>
<p>Un script es un método que se ejecuta cuando el usuario lleva a cabo ciertas órdenes. Por ejemplo, cuando pulsas NVDA+T, NVDA ejecuta un script en el módulo de órdenes globales llamado SayTitle. En Poedit, por ejemplo, cuando un traductor pulsa Control+Shift+A, NVDA leerá los comentarios para el traductor añadidos por el programador para ayudar a clarificar una cadena traducible dada. Esta orden no es una orden nativa de NVDA, pero se definió en el módulo de aplicación de Poedit para llevar a cabo esta función.</p>
<p>Normalmente, un complemento  que acepte scripts tendrá un mapa de lista orden:función en algún lugar en el módulo. El más simple es un diccionario de Gestos (órdenes), un diccionario python (llamado normalmente __gestures) que posee órdenes como teclas y scripts como valores para estas teclas (más de una tecla, u orden que puede vincularse a los scripts). Estos diccionarios se cargan cuando el complemento se carga y se borran cuando se sale de NVDA o cuando la aplicación para la que es el módulo de aplicación pierde el foco(es decir, el usuario ha cambiado a otro programa).</p>
<p>Otro modo de enlazar scripts es a través de inserción en tiempo de ejecución. Esto se hace creando otro diccionario de gestos diferente del diccionario __gestures que posea gestos sensibles al contexto tales como la manipulación de un sólo control. Entonces el desarrollador podría utilizar inputCore.bindGesture (o inputCore.bindGestures si se ha definido más de un gesto/script) para definir ciertos gestos a la vez, entonces utilizar inputCore.clearGestures luego inputCore.bindGestures(__gestures) para eliminar los gestos añadidos. Un modo más elegante, que consiste en scripts para objetos específicos, se tratará cuando hablemos sobre módulos de aplicación y cómo asignar gestos a partes específicas de un programa.</p>
<p>Para la mayoría de los scripts, no tienes que preocuparte por enviar el comando a la aplicación. Sin embargo, en caso de que el script realice tareas adicionales mientras envía la tecla a la aplicación activa, puedes utilizar <code>gesture.send()</code> para enviar el comando primero antes de realizar trabajo adicional.</p>
<p>De manera similar a los scripts, el módulo UI permite verbalizar o braillificar lo que tu complemento está haciendo. Esto se hace usando el mensaje <code>ui.message(algo que decir)</code> donde <code>algo que decir</code> se reemplaza por una cadena para que NVDA la diga. Alternativamente, puedes llamar a los métodos de manejo del habla y del braille directamente si deseas que el habla diga una cosa y la pantalla braille muestre otra. No repasaremos `ui.message' aquí (verás ejemplos de esos), pero lo más importante son los scripts, así que nos enfocaremos en eso en esta sección.</p>
<p>En el momento de escritura de esta guía, NVDA soporta entrada desde el teclado, pantallas braille con o sin teclado braille y pantallas táctiles. Estos tipos de entrada tienen un prefijo de gesto correspondiente (kb para teclado, br para braille y ts para pantalla táctil) que identifica el tipo de gesto. La salida puede enviarse vía voz y/o braille.</p>
<h3 id="ejemplo-2-un-diccionario-de-scripts-basico-y-un-mensaje-de-salida">Ejemplo 2: Un diccionario de scripts básico y un mensaje de salida</h3>
<p>En este ejemplo, definiremos dos scripts llamados "sayHello" y "sayGoodBye", luego los vincularemos a dos gestos separados.</p>
<pre><code># Un fragmento de ejemplo de asignación de un script desde una extensión global.
import ui

def script_sayHello(self, gesture):
    ui.message("Hello!")

def script_sayGoodBye(self, gesture):
    ui.message("Good Bye!")

__gestures={
    "kb:control+NVDA+1":"sayHello",
    "kb:Control+NVDA+2":"sayGoodBye"
}
</code></pre>
<p>Ahora cuando pulses Control+NVDA+1, NVDA dirá, "Hello", y cuando pulses Control+NVDA+2, NVDA dirá, "Good bye." Este es el código básico al recibir comandos y enviar mensajes.</p>
<h3 id="ejemplo-3-scripts-para-objetos-especificos">Ejemplo 3: Scripts para objetos específicos</h3>
<p>Al igual que en los objetos especializados anteriores, los scripts se pueden asignar a ciertos objetos especificando el diccionario de gestos para este objeto en particular. Aquí hay un ejemplo de un módulo de aplicación que define scripts para la ventana principal de un programa reproductor multimedia:</p>
<pre><code># Scripts para objetos para un programa.
from NVDAObjects.IAccessible import IAccessible

class Player(IAccessible):
    def script_saySongName(self, gesture):
        ui.message(self.songTitle_) #Supongamos que se haya definido esa variable.

    __gestures={
        "kb:NVDA+T":"saySongTitle"
    }

# Y en el módulo de aplicación principal:
def chooseNVDAObjectOverlayClasses(self, obj, clsList):
    if obj.windowClassName == "PlayerWindow": clsList.insert(0, Player)
</code></pre>
<p>Algo extraño ocurre con este ejemplo: normalmente, cuando se pulsa NVDA+T, NVDA dice el título de la ventana actual, pero en este ejemplo, anuncia el nombre de la canción. Este es el resultado de la búsqueda del script (ver abajo) donde el script para el objeto actual se ejecuta en lugar del script de título de comandos globales. Esta es una forma común de vincular nuevos scripts en tiempo de ejecución.</p>
<h3 id="orden-de-busqueda-de-scripts-y-conflictos-de-ordenes">Orden de búsqueda de scripts y conflictos de órdenes</h3>
<p>Según escribas tus complementos con scripts, necesitas recordar el siguiente orden de búsqueda de script cuando intentes asignar órdenes a scripts:</p>
<ol>
<li>Extensiones globales.</li>
<li>Módulos de aplicación para el programa actualmente enfocado.</li>
<li>Objetos de NVDA con los que estemos tratando.</li>
<li>Órdenes globales.</li>
</ol>
<p>Por ejemplo, si asignas la orden NVDA+Shift+Y a un script de módulo de aplicación, NVDA ejecutará ese script desde ese programa ya que ninguna extensión global está usando esta orden. Sin embargo, si se instala una extensión global que use esa orden, el script de la extensión global se ejecutará en lugar del script del módulo de aplicación. Del mismo modo, desde el ejemplo anterior, cuando se utilicen programas distintos a ese reproductor multimedia, NVDA ejecutará una orden desde la colección de órdenes globales cuando se pulse NVDA+T; pero mientras utilicemos este reproductor multimedia, NVDA+T anunciará el nombre de la canción (se da prioridad a los objetos de NVDA en los módulos de aplicación).</p>
<p>Debido a la regla anterior, se debe tener cuidado al definir un script para un complemento. Para ayudarte con esto, mantén las siguientes directrices a mano:</p>
<ol>
<li>En primer lugar, consulta la referencia rápida de órdenes de NVDA para ver si la orden que deseas utilizar se ha definido en las órdenes globales. Deberías tratar de minimizar los conflictos con las órdenes de NVDA incorporadas. Una excepción son las órdenes para los módulos de aplicación, donde una misma orden puede ser utilizada de forma diferente de un programa a otro.</li>
<li>Lee la documentación de los complementos (especialmente las extensiones globales) para ver si algún complemento está utilizando esta orden y, en caso afirmativo, ponte en contacto con el autor del complemento para obtener un vínculo alternativo.</li>
</ol>
<h3 id="otros-comentarios-sobre-scripts">Otros comentarios sobre scripts</h3>
<ul>
<li>Puedes utilizar cualquier modificador como parte de las órdenes para scripts (por ejemplo, Alt+NVDA+letra). Sin embargo, para evitar conflictos de órdenes, intenta reducir al mínimo el uso de órdenes que los programas puedan utilizar como Control+letra, Alt+Shift+letra, etcétera.</li>
<li>Al asignar órdenes de teclado, las etiquetas de las teclas del teclado no distinguen entre mayúsculas y minúsculas.</li>
<li>Puedes definir una categoría de script para mostrar al usuario dónde se utilizará su script adicional (mostrado en el cuadro de diálogo Gestos de entrada en NVDA 2013.3 o posterior). Hay dos maneras de hacerlo: a nivel de módulo mediante el atributo <code>scriptCategory</code> del módulo adicional, o bien designando la categoría para cada script mediante el atributo <code>script_name.category</code>. Se recomienda nombrar la categoría de script del mismo modo que el nombre del complemento.</li>
<li>Puedes definir el mensaje del modo de ayuda de entrada para un script utilizando el atributo <code>__doc__</code> (comúnmente conocido como docstrings). El atributo <strong>doc</strong> también se utiliza en el diálogo de Gestos de entrada para mostrar la descripción de un script.</li>
<li>Si necesitas dejar uno o más scripts sin asignar (por ejemplo, si un gesto entra en conflicto con una orden global), no incluyas el vínculo del gesto para el script en el diccionario de gestos. Esto ayuda a minimizar los conflictos de gestos y permite a los usuarios asignar gestos personalizados para los scripts.</li>
<li>Si hay dos objetos, A y B, y si B hereda de A y ambos contienen la misma orden para un script, puedes asignar "None" al nombre del script en el objeto B (subclase) para evitar una orden cuando se trate de órdenes del objeto B. Por ejemplo, si F10 está definido para ambos objetos y F10 no se utiliza en el objeto B, puedes asignar el comando F10 del objeto B a"None" para que F10 pueda enviarse al sistema operativo. Esto se implementa en algunos módulos del núcleo de NVDA y en el complemento StationPlaylist Studio.</li>
</ul>
<h3 id="eventos">Eventos</h3>
<p>Puedes pedirle a NVDA que haga algo si ocurre algo. Por ejemplo, puedes pedirle a NVDA que diga el nuevo nombre de un objeto cuando cambie su nombre, o decir el valor del nuevo elemento cuando se enfoque. Estas condiciones o acciones se denominan eventos.</p>
<p>Cuando se produce un evento, NVDA hace lo siguiente:</p>
<ol>
<li>Encuentra qué fue el evento (por ejemplo, una casilla de verificación obtiene el foco).</li>
<li>Realiza acciones para el evento (por ejemplo, indica el nombre y el estado marcado de esta casilla de verificación).</li>
<li>Pasa el evento por la cadena en caso de que otros objetos puedan tener acciones asociadas con el evento.</li>
</ol>
<p>Dependiendo de dónde se defina el evento, necesitarás dos o cuatro cosas al definirlo. Si se declara desde el módulo de un complemento, las partes requeridas son el nombre del evento, el módulo en cuestión (self), el objeto y el siguiente manejador en caso de que el objeto tenga otros eventos asociados. Si se define como parte de un objeto, se requiere el nombre del evento y el objeto (self).</p>
<p>Una rutina típica de eventos se ve así:</p>
<pre><code>def event_eventName(self, obj, nextHandler):
    # Hace alguna acción.
    nextHandler()
</code></pre>
<p>Para eventos de objeto, usa:</p>
<pre><code>def event_eventName(self):
    # Rutina de evento.
</code></pre>
<p>De hecho, hemos conocido un"evento" real antes: <code>event_NVDAObject-Init</code>. Se trata de un evento especial (uno de los muchos eventos definidos en NVDA) disparado cuando NVDA se encuentra con un nuevo objeto y lo inicializa de acuerdo con tu entrada (consulta la sección sobre sobreescritura de propiedades de un objeto para obtener más información). Veamos otros eventos que puedes ver mientras escribes tu complemento.</p>
<h3 id="ejemplo-4-anunciar-el-nombre-cambiado-de-un-control">Ejemplo 4: Anunciar el nombre cambiado de un control</h3>
<p>El siguiente código procede de uno de los complementos de módulos de aplicación.</p>
<p>A continuación se muestra una rutina para un evento que le indica el nombre de algún texto en la pantalla cuando el texto cambie.</p>
<pre><code>def event_nameChange(self, obj, nextHandler):
    if obj.windowClassName == "TStaticText": ui.message(obj.name)
    nextHandler()
</code></pre>
<p>Como puedes ver, siempre que el nombre del objeto de texto cambie, NVDA anunciará el nuevo nombre al usuario. El evento"cambio de nombre" es uno de los muchos eventos para los que puedes definir acciones personalizadas en tu complemento (la lista completa va a continuación).</p>
<p>Nota: puedes definir eventos para cualquier objeto de tu elección, especialmente controles en un programa (donde puedes definir acciones personalizadas para eventos en tu módulo de aplicación). Si este es el caso, debes asegurarte de que el control cumpla ciertas condiciones establecidas, como el nombre, la función, etc., para permitir que NVDA mantenga un"ojo" en ese objeto específico.</p>
<h3 id="lista-de-posibles-eventos">Lista de posibles eventos</h3>
<p>Esta es una lista de eventos comunes para los que puedes definir acciones personalizadas en tu complemento:</p>
<ul>
<li>gainFocus: el usuario ha movido el foco a un control específico, o el usuario acaba de cambiar a un programa.</li>
<li>loseFocus: el contrario a gainFocus.</li>
<li>nameChange: el nombre de un control ha cambiado (mira arriba para ver un ejemplo).</li>
<li>valueChange: El valor del control, como por ejemplo el texto de un campo de texto, ha cambiado.</li>
<li>stateChange: Útil para realizar un seguimiento de si las casillas de verificación, los botones y el estado de otros controles (marcados, seleccionados, etc.) han cambiado.</li>
<li>Foreground: el objeto que nos interesa se ha convertido en la ventana de primer plano del programa.</li>
</ul>
<p>Los eventos menos comunes que se utilizan en situaciones específicas incluyen:</p>
<ul>
<li>typedCharacter: el usuario ha introducido algo en un teclado.</li>
<li>appModule_gainFocus: el usuario ha cambiado a la aplicación donde se define un módulo de aplicación. Los usos comunes incluyen añadir órdenes de pantalla táctil para aplicaciones específicas, anunciar información adicional sobre el estado actual de la aplicación y así sucesivamente.</li>
<li>appModule_loseFocus: el contrario a appModule_gainFocus.</li>
<li>descriptionChange: la descripción de un control ofrecida por la API de accesibilidad ha cambiado.</li>
<li>suggestionsOpened: se utiliza en los controles donde se puede escribir algo y las sugerencias se mostrarán en base al texto introducido. La implementación predeterminada en NVDA reproduce un sonido para indicar la aparición de sugerencias.</li>
<li>suggestionsClosed: el contrario a suggestionsOpened. Los eventos de sugerencias requieren NVDA 2017.3 y el objeto debe heredar de la clase <code>NVDAObjects.behaviors.editableTextWithSuggestions</code>.</li>
</ul>
<h3 id="eventos-dentro-de-objetos">Eventos dentro de objetos</h3>
<p>La sección anterior describía las rutinas de eventos desde la perspectiva de un complemento. Esta es sólo una manera de definir los eventos. La otra manera es definir eventos desde dentro de los objetos, y es la misma que la anterior excepto que sólo toma un argumento (self).</p>
<h3 id="otros-componentes">Otros componentes</h3>
<p>Además de objetos, scripts y eventos, puedes añadir otros componentes en tu complemento para trabajar con controles específicos. Por ejemplo, puedes utilizar un módulo textInfo (como NVDAObjects.NVDAObjectTextInfo) para trabajar con offsets de texto y texto en campos de edición y otros controles, o utilizar módulos externos de desarrolladores externos para tareas especializadas como el acceso al registro de Windows (_winreg) y otras. También puedes utilizar los módulos integrados de Python (time, functools, etc.) para operaciones avanzadas.</p>
<p>Un componente notable es text infos, una forma de permitir que los complementos tengan acceso al texto ubicado en los objetos. Puedes acceder al texto, desplazarte por él (por ejemplo, mediante líneas y palabras) y manipular partes mediante intervalos de marcación y desplazamientos. Para la mayoría de los complementos, no es necesario definir un text info personalizado, ya que la API de accesibilidad subyacente proporcionará la información adecuada.</p>
<p>Otro componente útil es la biblioteca de presentación de texto matemático (mathPres). Esto se utiliza para permitir que NVDA acceda al contenido matemático en lugares como navegadores web, así como para que los complementos definan capas personalizadas de presentación matemática y formas de acceder al contenido matemático en varias aplicaciones. Hasta ahora, la recuperación de contenido matemático se hace en texto marcado en MathML con MathPlayer instalado.</p>
<p>Si deseas almacenar los ajustes para tu complemento, utiliza ConfigObj o el gestor de configuración integrado de NVDA para almacenar los archivos de configuración y los ajustes. ConfigObj define los ajustes como una colección de diccionarios que se pueden actualizar en tiempo real. También puedes pasar un mapa de validación para permitir al gestor de configuración (config.conf) de NVDA validar los ajustes para tu complemento y dejar que los ajustes adicionales se conviertan en ajustes específicos del perfil.</p>
<p>Finalmente, puedes pedirle a NVDA que realice algunas rutinas mientras el complemento se esté cargando o finalizando. Esto se hace definiendo el método <code>__init__</code> y <code>terminate</code> para el complemento. Dependiendo del tipo de extensión, utiliza:</p>
<ul>
<li>Para extensiones globales:
    def <strong>init</strong>(self):
        super(GlobalPlugin, self).<strong>init</strong>()
        # La rutina a hacer cuando la extensión global se cargue.
        # ¡Precaución! siempre deberías llamar al método super primero para inicializar la clase padre correctamente.</li>
<li>
<p>Para módulos de aplicación:
    def <strong>init</strong>(self, *args, <strong>kwargs):
        super(AppModule, self).<strong>init</strong>(*args, </strong>kwargs)
        # Lo que debería hacer NVDA cuando el módulo de aplicación se cargue.</p>
</li>
<li>
<p>Para terminar, independientemente del tipo de complemento:
    def terminate(self):
        # Hacer algo cuando el complemento termine.
        # ¡Precaución! nunca inicializes cualquier módulo del núcleo tal como GUI en el método terminate, ya que al hacerlo evitarás que NVDA salga correctamente.</p>
</li>
</ul>
<h3 id="construyamos-un-complemento">Construyamos un complemento</h3>
<p>Ahora tenemos una visión general básica de los componentes de los complementos, estamos listos para crear algunos complementos sencillos. Pero primero, repasemos el proceso real de desarrollo de complementos, consejos de depuración, lo que se debe hacer y lo que no se debe hacer y otras cosas.</p>
<h3 id="consejos-para-planificacion-y-desarrollo-de-complementos">Consejos para planificación y desarrollo de complementos</h3>
<p>A lo largo de los años, la comunidad de NVDA ha creado una serie de potentes complementos para los usuarios. Durante estos años, los redactores de complementos recopilaron algunos consejos útiles cuando se trata de escribir sus propios complementos. He aquí algunos de ellos:</p>
<ul>
<li>Conocer a NVDA: es importante que te familiarices con las órdenes, conceptos y consejos de NVDA. Suscríbete a los grupos de usuarios de NVDA para aprender más sobre NVDA y conocer cómo funciona, ya que lo ampliarás a través de tus complementos.</li>
<li>Conocer el producto que tienes a mano: como se mencionó anteriormente, es importante que conozcas el software para el que estás escribiendo el módulo de aplicación, los sintetizadores y las pantallas braille para los que vas a escribir el controlador, etcétera.</li>
<li>Planificar con anticipación: si sabes que mantendrás tu complemento durante varios meses o años, es útil tener un plan y escribir el código del complemento para prepararte para futuras extensiones. Por ejemplo, trabajando en las características que necesitas implementar ahora, dividiendo partes de un programa en objetos y así sucesivamente.</li>
<li>Listo para depurar y probar tu complemento: escribir tu código de complemento es sólo una parte del desarrollo global del complemento. La otra parte es probar y depurar tu complemento para asegurarte de que los usuarios lo utilizan con errores mínimos. A medida que escribas tus complementos, asegúrate de probar tu código con regularidad.</li>
<li>Lo más importante, diviértete.</li>
</ul>
<h3 id="que-hacer-y-que-no">Qué hacer y qué no</h3>
<p>Éstas son algunas cosas que deberías hacer y no hacer durante el desarrollo de un complemento:</p>
<ol>
<li>Habla con los usuarios: es importante recordar que tus complementos serán utilizados por los usuarios de NVDA de todo el mundo, por lo que es importante mantenerte en contacto con ellos para recopilar informes de errores y sugerencias.</li>
<li>Pide ayuda si es necesario: Si estás atascado, puedes pedir ayuda a otros desarrolladores de complementos en cualquier momento para obtener soluciones o consejos, o si lo necesitas, solicita la colaboración de otros desarrolladores de complementos.</li>
<li>Prueba tu complemento en más de un equipo: a veces, un error en un equipo puede ayudarte a resolver problemas en tu complemento en el equipo más adelante.</li>
<li>No utilices código imaginativo sin entender tus intenciones: un error tipográfico o una indentación olvidada puede convertirse en un problema cuando depuras un complemento.</li>
<li>Mantente al día con los cambios básicos de NVDA: a veces, puede que descubras que tu complemento no funcione debido a los cambios en el código del núcleo de NVDA. Asegúrate de leer la sección "Cambios para desarrolladores" en el documento Novedades de NVDA para mantenerte al día con los cambios de código que puedan afectar a tu complemento.</li>
</ol>
<h3 id="preguntas-frecuentes-sobre-componentes-de-complementos-y-desarrollo">Preguntas frecuentes sobre componentes de complementos y desarrollo</h3>
<p>P. Cuando trato de obtener un objeto usando un índice, éste obtiene uno después del índice que escribí.  </p>
<p>Este es el efecto colateral de la indexación basada en cero (el recuento comienza en 0).</p>
<p>P. Al importar un módulo, NVDA dice que no puede localizar el módulo.  </p>
<p>¿Escribiste el nombre correcto del módulo? ¿Extrajiste los archivos del módulo en la ubicación correcta? Intenta corregir el error tipográfico, observa la ruta de importación y vuelve a intentar importar.</p>
<p>P. ¿Cuál es la diferencia entre la revisión simple y la revisión normal y cuál debo usar?  </p>
<p>La revisión simple excluye los objetos de diseño como ventanas, agrupaciones, etc. que se colocan para propósitos de diseño. La revisión normal también incluye esto. La elección de usar la revisión simple versus la revisión normal depende de tu situación.</p>
<p>P. La orden para mi app module no funciona en mi app module, sino que NVDA hace otra cosa.  </p>
<p>Comprueba si está instalada una extensión global que utiliza la orden. Primero, quita la extensión global e inténtalo de nuevo.</p>
<p>P. ¿Cómo puedo utilizar Win32 API en mi complemento u objeto?</p>
<p>Existe un documento escrito por un desarrollador de complementos que habla sobre el uso de Win32 API en su complemento. Selecciona <a href="http://www.zlotowicz.pl/nvda/winapi.mdwn" title="Using Win32 API in your add-on">este enlace</a> para ver este documento.</p>
<p>P. ¿Cómo puedo crear diálogos en mi complemento?</p>
<p>Necesitas importar dos módulos: GUI (import gui) y WXPython (import wx).</p>
<p>P. ¿Puedo crear funciones y asignar variables fuera de las clases de módulo?</p>
<p>Sí. Esto es útil si necesitas hacer referencia a ellos desde dentro de la clase del complemento. Por ejemplo, es posible que tengas una función definida fuera de tu clase que necesitarás utilizar desde más de un método en una clase de extensión global.</p>
<p>P. Quiero guardar la configuración de usuario para mi complemento. ¿Se puede hacer esto?</p>
<p>Sí. Deberás utilizar la biblioteca ConfigObj(configObj) para administrar la configuración. Algunos complementos (como OCR) que utilizan archivos de configuración almacenan su configuración como un archivo ini en la carpeta de configuración de usuario de NVDA. En el caso de las extensiones globales, puedes cargar y guardar la configuración de usuario desde el complemento cuando se crea el complemento (<strong>init</strong>) o se finaliza (terminate), respectivamente. Esto no se puede hacer fácilmente con los módulos de aplicación. Además, tendrás que proporcionar una alternativa (órdenes, diálogos, etc.) en la que los usuarios puedan configurar opciones adicionales.</p>
<p>P. Tengo un script que llama a una función que se ejecuta durante mucho tiempo, y no puedo ejecutar órdenes de NVDA cuando se ejecuta mi script.</p>
<p>Una forma de solucionar esto es usando hilos (operaciones separadas e independientes en un programa) a través del módulo de hilos de Python. Para ello, crea un método que sepas que se ejecutará durante mucho tiempo y, a partir del script que llama a este método, crea un nuevo hilo (ver la documentación del módulo de hilos de Python) que se encargará de ejecutarlo. De esta forma, se pueden ejecutar otras órdenes de NVDA mientras el método adicional realiza su trabajo (consulta el módulo de reconocimiento de voz de Google para obtener un código de ejemplo).</p>
<p>P. Me gustaría conectar un módulo escrito en la sintaxis de Python 3 para utilizarlo como un complemento de NVDA.</p>
<p>Esto no se puede hacer fácilmente. Un módulo práctico para este propósito es six, que permite ejecutar el código Python 2 y 3. NVDA usa Python 2, pero ya se están haciendo trabajos de transición a Python 3.</p>
<p>P. Mi complemento usa componentes de interfaz gráfica, y después de instalar NVDA 2018.3, obtengo errores relacionados con WXPython.</p>
<p>NVDA 2018.3 usa WXPython 4, mientras que las versiones anteriores usan una versión más antigua de WXPython. Si quieres dar soporte a versiones anteriores de NVDA, debes emplear sentencias condicionales (if/else) y comprobaciones de versión, de tal forma que se elija el camino correcto al ejecutar el código.</p>
<p>P. Tras instalar NVDA 2019.1, los usuarios dicen que mis complementos no son compatibles.</p>
<p>NVDA 2019.1 introduce indicadores de compatibilidad (en ocasiones llamados rango de compatibilidad) de complementos que le dan la siguiente información:</p>
<ul>
<li>Versión mínima de NVDA (minimumNVDAVersion): un complemento puede especificar la versión mínima de NVDA necesaria para funcionar. Esto viene bien si necesitas utilizar funciones introducidas o modificadas en una versión dada de NVDA sin dar soporte a versiones de NVDA más antiguas.</li>
<li>Última versión de NVDA donde se ha probado (lastTestedNVDAVersion): le dice a NVDA la versión más alta soportada por el complemento. Si no se establece este indicador, NVDA tratará tus complementos como incompatibles con la versión más reciente.</li>
</ul>
<p>Las palabras entre paréntesis son claves de manifest. Con la llegada de NVDA 2019.1, estos indicadores de compatibilidad son obligatorios en todos los complementos.</p>
<p>P. Mi módulo de aplicación que estaba alojado en la carpeta appModules de la configuración de usuario no funciona en NVDA 2019.1.</p>
<p>Esto se debe a que NVDA 2019.1 ya no carga código de extensión personalizado situado en carpetas del directorio de configuración de usuario. Lee la sección de scratchpad para más detalles.</p>
<p>No incluimos preguntas frecuentes de programación relacionadas con Python, ya que hay sitios que responden a preguntas sobre Python, tales como las relacionadas con el estilo de codificación. Consulta estos documentos si tienes problemas con el código Python.</p>
<p>Ahora que hemos cubierto los componentes básicos de un complemento, vamos a aprender acerca de cómo empaquetar lo que sabes en tus propios módulos de complemento: extensiones globales, módulos de aplicación y controladores.</p>
<h2 id="introduccion-a-las-extensiones-globales">Introducción a las extensiones globales</h2>
<p>Una extensión global añade características disponibles en todas partes. Por ejemplo, si hay un control que se utilizará en muchas aplicaciones, puedes escribir una extensión global para manejarlas en NVDA. Otro ejemplo es la adición de funciones adicionales a NVDA que se puedan utilizar en todos los programas, como la capacidad de OCR, la gestión de marcadores de ubicación, etc.</p>
<p>Una extensión global es un archivo de código fuente de Python (.py) con el nombre de tu plugin. Por ejemplo, si estás añadiendo soporte para campos de edición enriquecidos en muchas aplicaciones, puedes nombrar la extensión como richEditSupport.py. Cuando los nombres, trata de ser breve para que puedas ver lo que hace tu extensión.</p>
<h3 id="plan-de-desarrollo-tipico-para-extensiones-globales">Plan de desarrollo típico para extensiones globales</h3>
<p>Normalmente, una extensión global se desarrolla así:</p>
<ol>
<li>Tú o alguien sugiere una característica o soporte para un control en particular a través de diferentes programas.</li>
<li>Planificas tu extensión global (consulta la sección sobre cuándo escribir o no escribir extensiones globales).</li>
<li>escribes tu extensión global y la pruebas. Una vez hecha y probada, liberas la extensión.</li>
</ol>
<p>Dado que las extensiones globales son archivos Python, puedes utilizar toda la potencia de python en el código de tu complemento. Además, dado que las extensiones globales tienen acceso a toda la potencia del código NVDA, como eventos, scripts y objetos, puedes utilizar los conceptos aprendidos en las secciones anteriores.</p>
<h3 id="el-codigo-de-la-extension-global">El código de la extensión global</h3>
<p>Como se ha mostrado anteriormente, el procedimiento para escribir extensiones globales es el mismo que para escribir cualquier programa Python, excepto que importas globalPluginHandler y colocas tu código de complemento en una clase llamada <code>GlobalPlugin</code> que hereda de <code>globalPluginHandler.GlobalPlugin</code> (consulta el ejemplo en el capítulo introductorio). Si necesitas utilizar módulos de terceros, debes colocar el paquete en la misma carpeta que el archivo de extensión global e importar los módulos externos. A continuación, define los objetos (normalmente objetos de superposición), métodos, etc. en tu código.</p>
<h3 id="cuando-escribir-o-no-escribir-extensiones-globales">Cuándo escribir o no escribir extensiones globales</h3>
<p>Dado que las extensiones globales se utilizan en todas partes, es posible que tengas la tentación de escribir soporte para una sola aplicación utilizando solamente una extensión global. Sin embargo, este no es el caso. Existen otras pautas a tener en cuenta a la hora de decidir si escribir una extensión global o no:</p>
<p>Podrías considerar la posibilidad de escribir una extensión global si:</p>
<ol>
<li>Tú o un usuario deseais utilizar una cierta característica en todas partes.</li>
<li>Necesitas soportar los mismos controles en diferentes aplicaciones, siempre que el control se comporte igual en estos programas.</li>
</ol>
<p>No deberías escribir una extensión global si:</p>
<ol>
<li>Si deseas mejorar el soporte para una sola aplicación.</li>
<li>Estás escribiendo soporte para sintetizadores de voz o pantallas braille.</li>
</ol>
<h3 id="algunas-cosas-mas-que-recordar-sobre-las-extensiones-globales">Algunas cosas más que recordar sobre las extensiones globales</h3>
<ul>
<li>Cuando escribes scripts en tu extensión global, las órdenes que les asignes tendrán prioridad (buscadas primero). Por lo tanto, es importante consultar la guía del usuario de NVDA y la ayuda de otros complementos para minimizar los conflictos de órdenes.</li>
<li>Cada extensión global debe estar ubicado en el directorio globalPlugins en la estructura de carpetas del complemento.</li>
<li>Es posible usar más de un archivo Python en tu extensión global. Si este es el caso, necesitas ponerlos en una carpeta (el nombre debe ser el nombre de la extensión) dentro de la carpeta globalPlugins, con el archivo principal de la extensión llamado <strong>init</strong>.py.</li>
<li>Si necesitas hacer algo cuando la extensión global esté cargada (como por ejemplo, cargar la configuración de usuario), debes escribir un método <strong>init</strong> en tu clase de extensión. En este método, debes llamar primero al método <strong>init</strong> en super (globalPluginHandler.GlobalPlugin) antes de hacer otro trabajo de inicialización. Además, si necesitas hacer algo cuando la extensión global termine, define el método terminate.</li>
</ul>
<p>Repasemos algunos ejemplos y ejercicios.</p>
<h3 id="ejemplo-1-escribir-braille-computerizado-utilizando-el-teclado-qwerty">Ejemplo 1: Escribir braille computerizado utilizando el teclado QWERTY</h3>
<p>Te vas a reunir con un cliente que utiliza el traductor braille de Duxbury (un popular programa de producción de documentos braille). Este cliente está trabajando con otro usuario de NVDA que desea escribir braille desde el teclado de su computadora en cualquier lugar. Basado en esto, decides escribir una extensión global, y encontraste un módulo que permite al teclado del ordenador actuar como un teclado braille usando una función.</p>
<p>La extensión global, llamada brailleWrite.py, se vería así:</p>
<pre><code># Un ejemplo de extensión global.

import qtbrl # El módulo de entrada braille.
import globalPluginHandler

class GlobalPlugin(globalPluginHandler.GlobalPlugin):
    brlentry = False # La entrada braille no está activa.

    def script_toggleBrailleEntry(self, gesture):
        self.brlentry = True if not self.brlentry else False # alternar modo de entrada Braille.
    script_toggleBrailleEntry.__doc__="Alterna la entrada Braille entre encendida y apagada."
    __gestures={
        "kb:NVDA+X":"toggleBrailleEntry"
    }
</code></pre>
<p>Con estos antecedentes en mente, prueba algunos de los ejercicios cortos que se presentan a continuación.</p>
<h3 id="ejercicios">Ejercicios</h3>
<ol>
<li>Escribe una extensión global llamada nvdaVersion.py para decir la versión actual de NVDA cuando se pulse NVDA+Shift+V.</li>
<li>Un usuario quiere oír la hora anunciada cada minuto. Usando el reloj en la bandeja del sistema, escribe una extensión global para anunciar cuándo cambia la hora (pista: es necesario usar un evento y comprobar la función del objeto reloj).</li>
</ol>
<h2 id="introducion-a-los-modulos-de-aplicacion">Introdución a los módulos de aplicación</h2>
<p>Un módulo de aplicación mejora el soporte para un programa en particular. Por ejemplo, puedes escribir un módulo de aplicación que agregue órdenes de conveniencia para leer varias partes de la pantalla, o puedes definir cómo debe comportarse un control particular en un programa.</p>
<p>Un módulo de aplicación es un archivo Python (.py) con el nombre correspondiente al nombre ejecutable de un programa. Por ejemplo, un módulo de aplicación para Winamp se llama winamp.py ya que el nombre ejecutable de Winamp es winamp.exe.</p>
<p>El mismo NVDA viene con varios app modules, como Winamp, Adobe Reader, programas de Microsoft Office y así sucesivamente.</p>
<h3 id="diferencias-entre-modulos-de-aplicacion-y-extensiones-globales">Diferencias entre módulos de aplicación y extensiones globales</h3>
<p>A primera vista, los módulos de aplicación pueden tener el mismo aspecto que cualquier extensión global. Sin embargo, los módulos de aplicación tienen propiedades adicionales de las que carecen las extensiones globales, incluyendo:</p>
<ul>
<li>En lugar de <code>globalPluginHandler</code>, necesitas importar <code>appModuleHandler</code>. La clase a implementar es <code>AppModule(appModuleHandler.AppModule)</code>.</li>
<li>Los módulos de aplicación se almacenan en la carpeta appModules de la estructura de directorios del complemento y reciben el mismo nombre que el nombre ejecutable del programa.</li>
<li>Puedes pedir a NVDA que entre en el modo de suspensión en un programa donde NVDA no hable o no tenga nada en braille mientras estés utilizando el programa, y cualquier orden de teclado que pulses será manejado directamente por el programa. Esto se hace estableciendo el atributo <code>sleepMode</code> en la clase AppModule a True.</li>
<li>La rutina <code>event_NVDAObject_init</code> sólo está disponible en los módulos de aplicación.</li>
<li>Puedes pedir a NVDA que vigile un objeto para manejar eventos aunque el usuario esté usando otra aplicación.</li>
</ul>
<h3 id="proceso-y-estrategias-de-desarrollo-de-modulos-de-aplicacion">Proceso y estrategias de desarrollo de módulos de aplicación</h3>
<p>Así se desarrolla un módulo de aplicación típico:</p>
<ol>
<li>Tú o un usuario solicitais soporte mejorado para un programa.</li>
<li>Si es posible, ponte en contacto con el proveedor de la aplicación (programador) para solicitar mejoras de accesibilidad para el programa por su parte.</li>
<li>Con o sin la cooperación del proveedor de aplicaciones, examinarías cómo funciona el programa y las áreas de la pantalla que necesitan ser leídas.</li>
<li>Escribe y prueba el módulo de aplicación (con usuarios) hasta que esté listo para su lanzamiento.</li>
</ol>
<p>A medida que escribas app modules, prueba estos consejos:</p>
<ol>
<li>Utiliza objetos para representar partes de un programa. Esto se hace en dos pasos: define el control para las partes de un programa a través de objetos (heredando de algún objeto como IAccessible), luego utiliza la rutina <code>chooseNVDAObjectOverlayClasses</code> para decirle a NVDA que trabaje con tu objeto personalizado cuando trabaje con ese control. Mira la sección de clases de superposición para consejos.</li>
<li>Si es posible, prueba tu app module utilizando dos o más versiones del programa para asegurarte de que tu módulo de aplicación funciona con esas versiones.</li>
<li>No deberías incorporar todas las características deseadas en la versión 1.0 - deja algunas de ellas para una futura versión.</li>
</ol>
<h3 id="ejemplo-2-modulo-de-aplicacion-simple-en-el-bloc-de-notas">Ejemplo 2: Módulo de aplicación simple en el Bloc de notas</h3>
<p>Supongamos que deseas averiguar qué línea estás editando en el Bloc de notas. Asumiendo que el Bloc de notas mostrará la barra de estado en todo momento, deseas asignar una combinación de teclas para leer el número de línea actual.</p>
<p>El módulo de aplicación para el Bloc de notas se vería así:</p>
<pre><code># El módulo de aplicación de ejemplo para bloc de notas, notepad.py.
import appModuleHandler
import api
import ui

class AppModule(appModuleHandler.AppModule):
    def script_sayLineNumber(self, gesture):
        # Supongamos que el número de línea sigue el formato "  ln 1".
        lineNumList = api.getStatusBar().name.split()
        lineNum = lineNumLisst[2]+linenumList[3]
        ui.message(lineNum)

    __gestures={
        "kb:NVDA+S":"sayLineNumber"
    }
</code></pre>
<p>Por lo tanto, cada vez que ejecutes el Bloc de notas, cuando pulses NVDA+S, NVDA dirá el número de línea.</p>
<h3 id="ejemplo-3-silenciar-nvda-en-openbook">Ejemplo 3: Silenciar NVDA en Openbook</h3>
<p>Openbook es un programa de lectura y escaneo de Freedom scientific. Como Openbook proporciona voz, puedes decir a NVDA que entre en modo latente mientras Openbook (openbook.exe) se ejecute usando el módulo de aplicación siguiente:</p>
<pre><code># Silenciar a NVDA en openbook, openbook.py.
import appModuleHandler

class AppModule(appModuleHandler.AppModule):
    sleepMode = True
</code></pre>
<p>Con esa única línea de código, NVDA entrará en modo latente en ese programa (sólo debes hacerlo si el programa proporciona soporte de voz y/o braille por sí solo).</p>
<h3 id="ejemplo-4-anunciar-cambios-de-propiedad-de-control-mientras-se-usa-otra-aplicacion">Ejemplo 4: Anunciar cambios de propiedad de control mientras se usa otra aplicación</h3>
<p>Puedes pedir a NVDA que gestione eventos específicos mientras se concentra en otra aplicación. Esto se hace llamando a eventHandler.requestEvents en el método <strong>init</strong> del módulo de aplicación. Para poder invocar esto, necesitas el ID de proceso (PID) para la aplicación, el nombre de clase de ventana para el objeto y el nombre del evento a tratar.</p>
<p>El siguiente código permite a NVDA anunciar los cambios de valor mientras se centra en otra aplicación.</p>
<pre><code># Ejemplo de módulo de aplicación para un programa de mensajería.
# El objeto que deseamos rastrear tiene el nombre de la clase de ventana "MessengerWindow".

import appModuleHandler
import eventHandler

class AppModule(appModuleHandler.AppModule):
    def __init__(self, *args, **kwargs):
        super(AppModule, self).__init__(*args, **kwards)
        eventHandler.requestEvents(self.processID, "MessengerWindow", "valueChange")
</code></pre>
<p>Una vez definidos, aunque estén enfocados en otra aplicación, se anunciarán nuevos mensajes (valores).</p>
<h3 id="propiedades-y-metodos-utiles-de-los-modulos-de-aplicacion">Propiedades y métodos útiles de los módulos de aplicación</h3>
<p><code>sleepMode</code> y <code>processID</code> son sólo dos de los muchos atributos que tienen los módulos de aplicación. Otras propiedades y métodos útiles utilizados en los módulos de aplicación incluyen los siguientes:</p>
<ul>
<li>appName: el nombre de la aplicación (normalmente el nombre del ejecutable).</li>
<li>productName: Registra el nombre real del producto para la aplicación.</li>
<li>productVersion: Registra la versión de la aplicación.</li>
<li>is64BitProcess: si es true, la aplicación es un proceso de 64 bits (sólo true si se está usando una aplicación de 64 bits en versiones Windows de 64 bits).</li>
<li>dumpOnCrash: si estás depurando aplicaciones que se bloquean con frecuencia, puedes llamar a esta función para permitir que NVDA guarde un volcado de esta aplicación en el directorio de archivos temporales para que puedas recuperarlo más tarde.</li>
</ul>
<p>Y otras propiedades. Escribe dir(obj.appModule) desde la [consola Python] para obtener la lista completa.</p>
<h3 id="otros-comentarios-sobre-los-modulos-de-aplicacion">Otros comentarios sobre los módulos de aplicación</h3>
<p>Aquí hay otras observaciones sobre los módulos de aplicación:</p>
<ul>
<li>Si encuentras que las diferentes versiones del programa están dispuestas de forma diferente, por ejemplo, las ubicaciones para los controles son diferentes, entonces puedes escribir código que pueda manejar estos casos. Hay una serie de opciones entre las que puedes elegir: añadir algunas constantes en tu módulo de aplicación para manejar diferentes ubicaciones de objetos, escribir código para estos controles (uno por versión) en objetos personalizados que se seleccionarán en el método de clases de superposición, etc.</li>
<li>Si es posible, intenta trabajar con los servicios que proporciona la aplicación, como los métodos COM (Component Object Model) (por ejemplo, el módulo de aplicación de Outlook), API's que proporciona la aplicación (como Winamp) y así sucesivamente.</li>
<li>Para soportar una aplicación que funcione igual que otro programa (especialmente si estás escribiendo un módulo de aplicación para una versión de 64 bits de un programa de 32 bits para el que has escrito un módulo de aplicación), utiliza el siguiente fragmento de código (llamado aliasing):
    from appName import *
donde appName es el nombre del app module y * (asterisco o estrella) significa importarlo todo. Para un ejemplo de esto, mira los módulos de aplicación de NVDA para Miranda32 y Miranda64.</li>
<li>Si deseas ampliar un app module que venga con NVDA, utiliza el siguiente fragmento de código (llamado sobreescritura del módulo incorporado):
    from nvdaBuiltin.appModules.appName import *
Donde appName es el módulo de aplicación que deseas ampliar. Por ejemplo, si deseas admitir diferentes controles en la calculadora de Windows (calc.py), utiliza:<br />
    from nvdaBuiltin.appModules.calc import *</li>
<li>Muchos módulos de aplicación (tanto integrados como de terceros) utilizan nombres de applicación como parte del nombre de una constante (un valor que no cambia). Por ejemplo, en el módulo Powerpoint de NVDA (powerpnt.py), muchas constantes comienzan con "PP". Del mismo modo, en el app module de Station Playlist Studio, muchas constantes en el archivo del módulo de aplicación (splstudio.py) comienzan con "SPL". Esto se usa para recordarte dónde se utilizan estas constantes.</li>
</ul>
<h2 id="controladores">Controladores</h2>
<p>Un controlador permite que un software como NVDA se comunique con el hardware o utilice la funcionalidad proporcionada por otro software. Normalmente, cuando la gente habla de controladores, usualmente se refiere a un programa instalado en una computadora que permite que el software se comunique con un hardware específico, como tarjetas de vídeo, teclados y demás.</p>
<p>En NVDA, los controladores se refieren a módulos que NVDA puede utilizar para comunicarse con un sintetizador de voz o una pantalla braille. Por ejemplo, puedes escribir un controlador de pantalla braille que envíe una salida braille a la pantalla braille, o pedirle a tu sintetizador que cambie de idioma y proporcione opciones configurables.</p>
<h3 id="componentes-del-controlador">Componentes del controlador</h3>
<p>Todos los controladores (independientemente del dispositivo de destino o software que se admita) importan los módulos apropiados, como "synthDriverHandler". Para la mayoría de los controladores, la mayoría del código del controlador trata sobre la comunicación con el dispositivo o software de destino, y todos los controladores deben definir la clase de controlador (synthDriverHandler.SynthDriver o braille.BrailleDisplayDriver).</p>
<p>Todas las clases de controladores, como mínimo, deben contener:</p>
<ul>
<li>Identificador del controlador: una cadena de caracteres como "oneCore" que identifique de forma unívoca a un controlador determinado.</li>
<li>Nombre amigable: el nombre que aparecerá en los cuadros de diálogo de sintetizador o de configuración braille.</li>
<li>Indicador de disponibilidad: un método de clase llamado <code>check</code> que indica a NVDA que el controlador está listo para su uso.</li>
<li>Gestor de conexiones: conjunto de rutinas que indican a NVDA cómo localizar un determinado sintetizador o una pantalla braille.</li>
<li>Manejador de salida: una función que realiza el procesamiento de salida real. Para los sintetizadores, el método <code>speak</code> debe estar presente; para las pantallas braille, se necesita el método <code>display</code>.</li>
</ul>
<p>Para los sintetizadores de voz, es necesario tener:</p>
<ul>
<li>Opciones de timbre de configuración del sintetizador: una lista de ajustes de los sintetizadores que los usuarios pueden ajustar mediante el timbre de configuración del sintetizador.</li>
</ul>
<p>Para las pantallas braille:</p>
<ul>
<li>Manejadores de entrada: si se desea la entrada de la pantalla braille, el autor del controlador debe implementar detectores para órdenes tales como teclas braille, botones de enrutamiento y hardware adicional.</li>
<li>conjunto de órdenes: un mapa que identifique las asignaciones de órdenes de NVDA para varios botones de hardware de la pantalla.</li>
</ul>
<h3 id="unas-pocas-cosas-importantes-que-recordar-antes-durante-y-despues-del-desarrollo-de-controladores">Unas pocas cosas importantes que recordar antes, durante y después del desarrollo de controladores</h3>
<ul>
<li>Antes de escribir un controlador, asegúrate de tener el software y/o hardware necesarios.</li>
<li>Asegúrate de estudiar los protocolos y las API's utilizadas por un sintetizador de voz o una pantalla braille (esto es más importante para las pantallas braille que pueden implementar diferentes protocolos).</li>
<li>Asegúrate de saber cómo comunicarte con el equipo o software: puertos, IDs USB, direcciones Bluetooth, configuración del puerto serie, dlls, etc.</li>
<li>Trabaja con otra persona que utilice el equipo o el software para el que estás escribiendo el (los) controlador (es).</li>
</ul>
<h3 id="pasos-tipicos-de-desarrollo-de-un-controlador">Pasos típicos de desarrollo de un controlador</h3>
<p>Cuando escribas controladores, es posible que desees seguir los pasos recomendados para el desarrollo de módulos de aplicación (planificación, comunicación con los proveedores, pruebas de usuario, etc.). Sin embargo, dado que los controladores requieren un conocimiento íntimo del hardware y/o del software, deberías dedicar más tiempo a probar tu controlador. Esto es más importante si estás escribiendo un controlador para una pantalla braille que puede enviar órdenes arbitrarias (órdenes braille, botones de enrutamiento, etc.).</p>
<h2 id="compartiendo-tu-complemento-y-experiencia-con-otros">Compartiendo tu complemento y experiencia con otros</h2>
<p>Una vez que hayas terminado de desarrollar tus complementos, es posible que desees compartir tu código con otros. A lo largo del camino, podrías aportar tu conocimiento para que otros puedan beneficiarse de tus experiencias.</p>
<p>Este capítulo está diseñado para proporcionar orientación sobre la liberación y el mantenimiento de complementos, así como para conectarte con los usuarios de complementos y otros desarrolladores del núcleo y de complementos de NVDA de todo el mundo.</p>
<h3 id="la-lista-de-complementos-de-nvda">La lista de complementos de NVDA</h3>
<p>Si deseas mantenerte en contacto con los usuarios de tu complemento o deseas aprender o contribuir con tu complemento a otros, suscríbete a[la lista de complementos de NVDA][4]. Esta es una lista de poco tráfico dedicada a discutir los complementos actuales y futuros, así como a revisar otros complementos creados por miembros de la comunidad o hacer que otros desarrolladores de complementos revisen sus complementos en todo el mundo.</p>
<h3 id="el-sitio-web-y-el-repositorio-de-codigo-de-los-complementos-de-la-comunidad-de-nvda">El sitio web y el repositorio de código de los complementos de la comunidad de NVDA</h3>
<p>To download or learn more about various add-ons created by NVDA users, visit <a href="https://addons.nvda-project.org">NVDA Community Add-ons web site</a>. You can browse currently available add-ons, view add-ons under development and read add-on development guidelines.</p>
<p>For developers wishing to read the code that powers various add-ons, you can search for add-on repositories stored on <a href="https://www.github.com/">GitHub</a>. The NVDA community add-on developers use <a href="https://www.git-scm.com">Git</a> for version control.</p>
<p>Algunos de los repositorios útiles y educativos son:</p>
<ul>
<li><a href="https://bitbucket.org/nvdaaddonteam/addontemplate/get/master.zip">add-on template</a>: este es el repositorio de código fuente para la plantilla de complementos de la comunidad.</li>
<li><a href="https://github.com/nvdaes/placeMarkers">Place markers de Noelia Martínez</a>: agrega funcionalidad de marcadores de posición y proporciona un buen ejemplo sobre el uso de text infos.</li>
<li><a href="https://github.com/josephsl/wintenApps">Windows 10 App Essentials de Joseph Lee</a>: proporciona soporte mejorado para Windows 10 y varias aplicaciones universales, considerado un clásico en la forma en que las extensiones globales y módulos de aplicaciones trabajan juntos e incluye ejemplos de clases de superposición y comportamientos de control que se derivan de los objetos UI Automation.</li>
<li><a href="https://github.com/nvdaes/readFeeds">Read Feeds de Noelia Martínez</a>: facilita el descubrimiento de feeds en varios sitios web e incluye un ejemplo sencillo de almacenar y validar configuraciones adicionales.</li>
<li><a href="https://github.com/nvdaremote/nvdaremote">NVDA Remote Support de Christopher Toth y Tyler Spivey</a>: un popular complemento utilizado para la solución remota de problemas y soporte técnico, proporciona ejemplos de cómo se utilizan varias bibliotecas externas de Python.</li>
<li><a href="https://github.com/josephsl/stationPlaylist">StationPlaylist Studio de Joseph Lee</a>: mejora el uso de StationPlaylist Studio, proporciona ejemplos interesantes sobre las clases de superposición y la API de aplicaciones, el uso de hilos y diálogos adicionales y otras interfaces de usuario.</li>
</ul>
<h2 id="informacion-miscelanea">Información miscelánea</h2>
<p>Por favor, añade material adicional a esta guía. En el Equipo de Complementos de NVDA agradecemos las contribuciones de otros desarrolladores y usuarios de complementos por todo el mundo.</p>
<h2 id="apendices">Apéndices</h2>
<h3 id="apendice-a-diccionario-de-terminos-de-complemento">Apéndice A: Diccionario de términos de complemento</h3>
<p>Los siguientes términos se utilizan a lo largo de esta guía de desarrollo, así como en la comunidad de complementos para referirse a complementos, procesos de desarrollo, etcétera.</p>
<ul>
<li>Complemento: una extensión para un programa. En el mundo de NVDA, un complemento se refiere a paquetes adicionales que los usuarios pueden instalar para ampliar la funcionalidad de NVDA, mejorar la compatibilidad con una aplicación o añadir nuevos sintetizadores de voz o pantallas braille.</li>
<li>Aplicación: sinónimo de programa.</li>
<li>Módulo de aplicación: un módulo que añade o mejora el soporte para un programa.</li>
<li>API: interfaz de programación de aplicaciones. En inglés, Application Programming Interface.</li>
<li>Clase base: clase padre de un objeto.</li>
<li>Pantalla Braille: un hardware o software que emite texto a través de una salida braille táctil y/o permite a los usuarios ingresar texto a través de un teclado braille u otros mecanismos de entrada.</li>
<li>Módulo integrado: un módulo que viene con NVDA y que puede ser sobreescrito o ampliado por los complementos opcionalmente.</li>
<li>Caret: cursor que se muestra en pantalla, generalmente visto al editar texto o al navegar por documentos.</li>
<li>clase: definición de un objeto.</li>
<li>Evento: una rutina llamada cuando suceden ciertas cosas, como la introducción de caracteres, cambios en el texto de la pantalla, una casilla de verificación marcada y así sucesivamente.</li>
<li>Función: un pedazo de código que realiza algo con uno o más parámetros de entrada y opcionalmente devuelve algo.</li>
<li>Gesto: una entrada como pulsaciones de teclas, gestos en la pantalla táctil, teclas braille, etcétera.</li>
<li>Extensión global: un módulo que añade características en todas partes.</li>
<li>Módulo: conjunto de variables, funciones, clases y otros dentro de un fichero.</li>
<li>Objeto: una definición de clase con vida propia.</li>
<li>Script: una función que se adjunta (asigna) a un gesto.</li>
<li>Sintetizador de voz: un software o hardware que convierte texto y varias órdenes de voz enviados a la salida de voz.</li>
<li>Variable: un marcador de posición temporal para algunos datos.</li>
</ul>
<h3 id="apendice-b-programacion-y-conceptos-de-python-que-todo-desarrollador-de-complementos-necesita-saber">Apéndice B: Programación y conceptos de Python que todo desarrollador de complementos necesita saber</h3>
<p>La siguiente lista resume los conceptos que todos los desarrolladores de complementos necesitarán conocer cuando escriban complementos.</p>
<ul>
<li>API: un conjunto de documentación y muestras de código utilizado para permitir que un programa o hardware interactúe con otro software o hardware.</li>
<li>Clase base: una clase que proporciona métodos base, atributos y propiedades para que otros objetos hereden y amplíen. Sinónimo de superclase y clase padre.</li>
<li>Clase hija: una clase que deriva su poder de una o más clases básicas.</li>
<li>Clase: definición de objetos, incluyendo métodos, atributos y comportamientos esperados. Todas las clases y atributos de Python son públicos; pueden "llegar a ser privados" mediante el uso de convenciones de nomenclatura como prefijar un nombre de variable con subrayados (_).</li>
<li>Bloque de código: colección de código.</li>
<li>Compilación: traducción de un lenguaje de programación de alto nivel a un lenguaje de programación de bajo nivel apto para la ejecución en máquina.</li>
<li>Programación dirigida por eventos: un paradigma de programación basado en el seguimiento, la reacción y el manejo de eventos.</li>
<li>Excepción: una o más circunstancias en tiempo de ejecución que impiden el funcionamiento normal de un programa, como negarle el acceso a un recurso, problemas de uso del nombre en el código y otros casos.</li>
<li>GUI: Interfaz gráfica de usuario.</li>
<li>Manejador: una referencia opaca a un recurso tal como un archivo, socket TCP, ventana, etcétera.</li>
<li>Relación tiene vs. es: el primero se refiere a atributos de una sola clase, y el segundo a clases heredadas.</li>
<li>Sintaxis basada en la indentación: uso de indentaciones tales como tabulaciones para denotar bloques de código.</li>
<li>Herencia: habilidad para que una o más clases padres provean métodos y atributos básicos para que las clases hijas sobreescriban o amplíen según surja la necesidad.</li>
<li>Interpretar: ejecutar un programa escrito en un lenguaje de alto nivel sin compilarlo primero.</li>
<li>Objeto: instancia de ejecución de una o más clases.</li>
<li>Jerarquía de objetos: cómo se organizan los elementos de pantalla mediante la relación padre-hijo (contenedor - contenido).</li>
<li>Programación orientada a objetos: un paradigma de programación que define soluciones a problemas o representa cosas reales a través de clases y objetos.</li>
<li>Alcance: dónde las variables, funciones, clases y objetos se definen en código.</li>
</ul>
<h3 id="apendice-c-comparacion-de-tipos-de-complementos">Apéndice C: Comparación de tipos de complementos</h3>
<p>La siguiente tabla compara varios tipos de complementos y cuándo utilizarlos.</p>
<table>
<thead>
<tr>
<th>Tarea o característica</th>
<th>Extensión global</th>
<th>Módulo de aplicación</th>
<th>Controlador</th>
</tr>
</thead>
<tbody>
<tr>
<td>Puede usarse en todas partes</td>
<td>Sí</td>
<td>No</td>
<td>Sí</td>
</tr>
<tr>
<td>Restricciones de nombrado</td>
<td>No (limitado por las convenciones de nombrado de ficheros de Windows)</td>
<td>Debe llamarse como el ejecutable</td>
<td>No (limitado por las convenciones de nombrado de ficheros de Windows)</td>
</tr>
<tr>
<td>Recupera varios controles, incluyendo el control enfocado</td>
<td>Sí</td>
<td>Sí</td>
<td>No</td>
</tr>
<tr>
<td>Las órdenes pueden utilizarse en cualquier lugar</td>
<td>Sí</td>
<td>No</td>
<td>Sólo los controladores de pantalla braille si se definió</td>
</tr>
<tr>
<td>Manejar eventos tales como cambios del foco</td>
<td>Sí</td>
<td>Sí</td>
<td>No</td>
</tr>
<tr>
<td>Definir objetos personalizados para representar controles</td>
<td>Sí</td>
<td>Sí</td>
<td>No</td>
</tr>
<tr>
<td>Definir acciones personalizadas al realizarse cuando el módulo se cargue y se descargue</td>
<td>Sí</td>
<td>Sí</td>
<td>Sí</td>
</tr>
<tr>
<td>Definir acciones personalizadas a realizarse cuando ocurran cambios de perfil y otros eventos</td>
<td>Sí</td>
<td>Sí</td>
<td>Sí</td>
</tr>
<tr>
<td>Puede modificar atributos de objeto en tiempo de ejecución</td>
<td>No</td>
<td>Sí</td>
<td>No</td>
</tr>
<tr>
<td>Modifica rutinas de salida de voz y otras y la experiencia de presentación (Por ejemplo speech.cancelSpeech, braille.handler.update, etc.)</td>
<td>Sí</td>
<td>Sí</td>
<td>No</td>
</tr>
<tr>
<td>Incluir opciones personalizadas</td>
<td>Sí</td>
<td>Sí</td>
<td>Sólo sintetizadores de voz</td>
</tr>
<tr>
<td>Puede parchear funciones de NVDA, classes y módulos a voluntad</td>
<td>Sí</td>
<td>No se aconseja</td>
<td>No</td>
</tr>
<tr>
<td>Sujeto a cambios de perfil de configuración</td>
<td>No</td>
<td>Sí</td>
<td>Sí</td>
</tr>
<tr>
<td>Puede llamar a bibliotecas externas escritas en C y otros lenguajes y empaquetadas como DLLs</td>
<td>Sí</td>
<td>Sí</td>
<td>Sí</td>
</tr>
</tbody>
</table>
<h3 id="apendice-d-notas-y-referencias-para-creadores-de-scripts-de-otros-lectores-de-pantalla">Apéndice D: notas y referencias para creadores de scripts de otros lectores de pantalla</h3>
<p>Si escribes scripts para lectores de pantalla como JAWS para Windows o Window-Eyes, asegúrate de repasar esta sección ya que te presenta las tareas comunes que puedes realizar con NVDA y otras notas.</p>
<table>
<thead>
<tr>
<th>Tarea</th>
<th>función /clase/módulo de NVDA o de Python</th>
<th>Notas</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cancelar voz</td>
<td>speech.cancelSpeech()</td>
<td>Detiene la voz.</td>
</tr>
<tr>
<td>Verbalizar algo</td>
<td>speech.speakMessage(mensaje) o como parte de ui.message(mensaje)</td>
<td>la función ui.message también realiza la salida braille.</td>
</tr>
<tr>
<td>Braillificar algo</td>
<td>braille.handler.message(mensaje) o ui.message(mensaje)</td>
<td>Igual que arriba.</td>
</tr>
<tr>
<td>Mostrar una ventana HTML</td>
<td>ui.browseableMessage(mensaje, título, isHTML = True)</td>
<td>Imita el visor virtual excepto a la hora de mostrarse en pantalla.</td>
</tr>
<tr>
<td>Recuperar objeto con el foco</td>
<td>algo = api.getFocusObject()</td>
<td></td>
</tr>
<tr>
<td>Recuperar ventana en primer plano</td>
<td>primerplano = api.getForegroundObject()</td>
<td></td>
</tr>
<tr>
<td>Título de la ventana activa (si está presente)</td>
<td>foreground.name</td>
<td></td>
</tr>
<tr>
<td>Averiguar qué objeto es el navegador de objetos</td>
<td>obj = api.getNavigatorObject()</td>
<td>Este podrá ser o no ser el control enfocado.</td>
</tr>
<tr>
<td>Recuperar el manejador de ventana para un objeto dado</td>
<td>hwnd = obj.windowHandle</td>
<td>Obtiene el objeto a través de las funciones api.get*Object().</td>
</tr>
<tr>
<td>Comprobar el nombre de la clase de ventana</td>
<td>obj.windowClassName == algo</td>
<td></td>
</tr>
<tr>
<td>Asegurarse de que el objeto padre tiene el ID de control de ventana correcto</td>
<td>if obj.parent.windowControlID == algo: instrucciones</td>
<td></td>
</tr>
<tr>
<td>El objeto padre no proporciona lo que yo quiero, pero el abuelo lo hace</td>
<td>algo = obj.parent.parent.atributo</td>
<td></td>
</tr>
<tr>
<td>La etiqueta de un elemento de lista es el nombre de su primer objeto hijo.</td>
<td>obj.name = obj.firstChild.name</td>
<td></td>
</tr>
<tr>
<td>Deseo que la etiqueta de control del objeto enfocado y la descripción del objeto anterior se anuncien cuando pulso NVDA+Tab</td>
<td>En reportFocus(self): obj.name += " " + obj.previous.description</td>
<td></td>
</tr>
<tr>
<td>Anunciar si el estado cambia si y sólo si el siguiente objeto es la barra de herramientas que estoy buscando.</td>
<td>In event_stateChange(self): toolbar = obj.next; if toolbar.role == controlTypes.ROLE_TOOLBAR and toolbar.attribute = loqueestoybuscando y condiciones adicionales ...: instrucciones</td>
<td>Para una mejor legibilidad, coloca cada declaración en líneas separadas con indentaciones correctas.</td>
</tr>
<tr>
<td>Anunciar el nombre de un objeto en pantalla (siempre que se pueda utilizar la navegación por objeto)</td>
<td>obj = api.getForegroundObject().ruta...; ui.message(obj.name)</td>
<td>Trata de colocar cada sentencia en su propia línea con las indentaciones correctas aplicadas. La ruta se refiere a obj.next/previous/parent/firstChild/lastChild/children[index]/getChild(index) y así sucesivamente.</td>
</tr>
<tr>
<td>Comprueba si el rol del objeto es el que deseas</td>
<td>obj.role == controlTypes.ROLE_*</td>
<td>ROLE_* puede ser cualquier rol que estés buscando.</td>
</tr>
<tr>
<td>Búsqueda de un texto específico en el nombre del objeto</td>
<td>textobuscado in obj.name</td>
<td>Esta es una tarea típica de los miembros de una cadena de texto.</td>
</tr>
<tr>
<td>¿Empieza la etiqueta del control con un texto específico?</td>
<td>obj.name.startswith(textobuscado)</td>
<td></td>
</tr>
<tr>
<td>Longitud de un campo de texto con valor fácilmente recuperable</td>
<td>len(obj.value)</td>
<td>Esto funciona si se puede encontrar el valor del campo.</td>
</tr>
<tr>
<td>Es una casilla marcada</td>
<td>controlTypes.STATE_CHECKED in obj.states</td>
<td>obj.states es un conjunto. En primer lugar, verifica que el rol es de una casilla de verificación.</td>
</tr>
<tr>
<td>Cuántos elementos hay en una lista</td>
<td>algunaLista.childCount</td>
<td>Siempre que la lista proporcione una correcta implementación subyacente para obtener el recuento de elementos.</td>
</tr>
<tr>
<td>Dónde se encuentra el objeto en la pantalla</td>
<td>obj.location</td>
<td>Esto devuelve una tupla de cuatro elementos, es decir, coordenadas x e y de la esquina superior izquierda del objeto, así como longitud y anchura. Por ejemplo, en el objeto Shell (escritorio) con una resolución de pantalla de 1920 por 1080 píxeles, el valor de retorno será (0,0,1920,1080).</td>
</tr>
<tr>
<td>¿Es este un control MSAA?</td>
<td>isinstance(obj, NVDAObjects.IAccessible.IAccessible)</td>
<td>Una implementación típica es importar IAccessible desde NVDAObjects.IAccessible y hacer isinstance(obj, IAccessible).</td>
</tr>
<tr>
<td>Posición de un elemento de lista MSAA</td>
<td>item.IAccessibleChildID</td>
<td>Siempre y cuando esto se implemente correctamente. El valor predeterminado para los controles que no sean elementos de lista o elementos de vista de árbol es 0.</td>
</tr>
<tr>
<td>Necesito trabajar con métodos de un objeto IAccessible directamente</td>
<td>obj.IAccessibleObject.method</td>
<td>primero, descubre cómo usar el método MSAA dado para un control, y después recupera el propio objeto IAccessible y llama al método.</td>
</tr>
<tr>
<td>Dame el elemento UIA que proporciona un control UIA</td>
<td>obj.UIAElement</td>
<td>útil si quieres realizar operaciones de cliente UIA en este elemento.</td>
</tr>
<tr>
<td>ID de automatización para un elemento UIA</td>
<td>obj.UIAElement.cachedAutomationID</td>
<td>Primero, comprueba si el objeto es un control UIA.</td>
</tr>
<tr>
<td>Framework utilizado para generar este objeto UIA</td>
<td>obj.UIAElement.cachedFrameworkID</td>
<td>El framework GUI utilizado para programar este objeto. Los frameworks más comunes son Direct UI, Windows Presentation Foundation (WPF) con UIA habilitado, XAML (lenguaje extensible de programación de aplicaciones) y Microsoft Edge.</td>
</tr>
<tr>
<td>Quiero pedirle a UIA los valores de una propiedad específica</td>
<td>obj._getUIACacheablePropertyValue(propertyID)</td>
<td>asumiendo que el objeto es un control UIA, pásale el identificador de la propiedad que quieres conocer como argumento de esta función. Si la propiedad está soportada, se devolverá un valor válido. Si no, se lanzará un error COM.</td>
</tr>
<tr>
<td>Nombre ejecutable de cualquier objeto</td>
<td>obj.appModule.appName</td>
<td>appModule es el atributo de cualquier objeto que se pueda representar dentro de una aplicación como el control enfocado.</td>
</tr>
<tr>
<td>Enviar combinaciones de teclas</td>
<td>gesture.send()</td>
<td>Se debe llamar desde un script asociado a la combinación de teclas deseada.</td>
</tr>
<tr>
<td>Manejo de múltiples pulsaciones de teclas</td>
<td>scriptHandler.getLastScriptRepeatCount()</td>
<td>0 significa que la orden se ha pulsado una vez.</td>
</tr>
<tr>
<td>Quiero asignar la fila Control+Alt+número a un script</td>
<td>En initOverlayClass(self): for key in range(10): self.bindGesture("control+alt+%s"%(key), "elscript")</td>
<td>Para Python 2, utiliza xrange en su lugar. Para facilidad de lectura, indenta cada sentencia en líneas separadas.</td>
</tr>
<tr>
<td>proporcionar mensajes de ayuda para entradas</td>
<td>script_somescript.<strong>doc</strong></td>
<td>Efectivamente, la cadena de documentación del script se trata como su mensaje de ayuda para entradas.</td>
</tr>
<tr>
<td>Manejar los cambios de nombre</td>
<td>event_nameChange(self, obj, nextHandler)</td>
<td>El cuerpo debe consistir en lo que se debe hacer, terminando con una llamada a la función nextHandler ().</td>
</tr>
<tr>
<td>Anuncios de cambio de región viva</td>
<td>event_liveRegionChange(self, obj, nextHandler)</td>
<td>De forma predeterminada, el nuevo texto será hablado y/o braillificado.</td>
</tr>
<tr>
<td>Transformar instantáneamente una ventana en un diálogo</td>
<td>En chooseNVDAObjectOverlayClasses(self, obj, clsList): si encuentras la ventana que quieres: clsList.insert(0, NVDAObjects.Behaviors.Dialog)</td>
<td>Asegúrate de identificar que esta ventana es realmente un diálogo. Si se hace correctamente, los contenidos de este"diálogo" se anunciarán automáticamente.</td>
</tr>
<tr>
<td>Estoy trabajando con una ventana de terminal</td>
<td>Hereda de NVDAObjects.behaviors.Terminal</td>
<td></td>
</tr>
<tr>
<td>Deseo añadir órdenes de navegación de tabla para un objeto que todavía no se muestra como tabla</td>
<td>Hereda de NVDAObjects.behaviors.RowWithFakeNavigation</td>
<td>Esta clase define el mensaje del modo de ayuda de entrada y una implementación básica para las órdenes de navegación de tabla (Control+Alt+flechas).</td>
</tr>
<tr>
<td>Necesito indicadores para proporcionar soporte mejorado para una aplicación Java</td>
<td>NVDAObjects.JAB y módulo JABHandler</td>
<td>Java Access Bridge (de 32 y 64 bits) debería instalarse.</td>
</tr>
<tr>
<td>Añadir soporte para una aplicación con funcionalidad similar a la de otra aplicación</td>
<td>Importar contenidos del módulo de aplicación fuente a través de from nombremódulo import *</td>
<td>Se conoce con el nombre de "Aliasing".</td>
</tr>
<tr>
<td>Reproducir un tono</td>
<td>tones.beep(hertz, duration)</td>
<td>Duración en milésimas de segundo.</td>
</tr>
<tr>
<td>Reproducir un tono en el altavoz izquierdo</td>
<td>tones.beep(hertz, duration, leftVolume=100, rightVolume=0)</td>
<td></td>
</tr>
<tr>
<td>Reproducir un fichero de sonido wav</td>
<td>nvwave.playWaveFile(path)</td>
<td>Por ejemplo, nvwave.playWaveFile(r"test.wav")</td>
</tr>
<tr>
<td>Obtener información de texto para un objeto determinado</td>
<td>obj.TextInfo</td>
<td>Observa la "T" mayúscula.</td>
</tr>
<tr>
<td>Comprobar si el eco de teclado (caracteres tecleados) está activado</td>
<td>config.conf["keyboard"]["speakTypedCharacters"]</td>
<td></td>
</tr>
<tr>
<td>activar la verbalización de las teclas de órdenes sin abrir el cuadro de diálogo de configuración</td>
<td>config.conf["keyboard"]["speakCommandKeys"] = True</td>
<td>El usuario debe activar esto a través del diálogo de opciones de teclado.</td>
</tr>
<tr>
<td>El Modo foco/modo formularios está activo</td>
<td>obj.treeInterceptor.passThrough</td>
<td>Si es true, el modo foco/modo formularios está activado mientras se utilizan los documentos del modo exploración.</td>
</tr>
<tr>
<td>Dispone de soporte para pantalla táctil</td>
<td>touchHandler.handler is not None</td>
<td>Si no es None, el soporte táctil está activo y disponible.</td>
</tr>
<tr>
<td>Obtener la versión de NVDA</td>
<td>versionInfo.version</td>
<td></td>
</tr>
<tr>
<td>Quiero hacer algo cada vez que cambien los perfiles de configuración</td>
<td>config.post_configProfileSwitch</td>
<td>debes registrar una función que escuche esta acción, y hacer que haga algo cada vez que los perfiles cambien.</td>
</tr>
<tr>
<td>Hazme saber si esta es una versión de desarrollo</td>
<td><strong>debug</strong></td>
<td>Si esta variable es True, la versión actual es de desarrollo. En cualquier otro caso, es una liberación oficial.</td>
</tr>
<tr>
<td>Necesito ciertas características para que mi código funcione mejor</td>
<td>hasattr(módulo, algo)</td>
<td>esto te permite comprobar la existencia de una característica o atributo que puedas necesitar, de tal forma que puedas dar soporte a versiones antiguas y nuevas del código.</td>
</tr>
<tr>
<td>Versión de Windows</td>
<td>sys.getwindowsversion</td>
<td>Esto devuelve una tupla de cinco elementos: versión principal, versión menor, número de compilación, plataforma y versión del Service Pack.</td>
</tr>
<tr>
<td>¿Es Windows de 64 bits?</td>
<td>os.environ("PROCESSOR_ARCHITEW6432") in ["AMD64", "ARM64"] o también os.path.exists(r"C:\Program Files (X86)")</td>
<td>El método variable de entorno es más fiable. A partir de 2017.4, se debe comprobar tanto AMD64 como ARM64, especialmente cuando se admite Windows 10 en ARM.</td>
</tr>
<tr>
<td>Acceso al registro</td>
<td>Módulo _winreg</td>
<td>Cambiado a "winreg" en Python 3.</td>
</tr>
<tr>
<td>Abrir un sitio web con el navegador web predeterminado</td>
<td>os.startfile(URL)</td>
<td></td>
</tr>
<tr>
<td>Descargar cabeceras para un archivo en la web</td>
<td>resource = urllib.urlopen(URL)</td>
<td></td>
</tr>
<tr>
<td>Trabajar con datos JSON</td>
<td>Módulo json</td>
<td></td>
</tr>
<tr>
<td>Reservar algo de memoria en algún lugar</td>
<td>ctypes.windll.kernel32.VirtualAllocEx()</td>
<td>La forma más rápida de hacerlo es la función winKernel.virtualAllocEx.</td>
</tr>
<tr>
<td>Enviar un mensaje a otro proceso</td>
<td>ctypes.windll.user32.SendMessageW()</td>
<td>El camino más corto es la función winUser.sendMessage().</td>
</tr>
<tr>
<td>Hora actual en segundos</td>
<td>time.time()</td>
<td>Devuelve segundos transcurridos desde el 1 de enero de 1970 a medianoche.</td>
</tr>
<tr>
<td>Crear un cuadro de mensaje</td>
<td>gui.messageBox</td>
<td>Una fina envoltura alrededor de la clase wx.MessageBox.</td>
</tr>
<tr>
<td>Crear un diálogo personalizado</td>
<td>wx.Dialog</td>
<td></td>
</tr>
<tr>
<td>Ejecutar varias tareas en segundo plano a la vez</td>
<td>threading.Thread</td>
<td>En realidad, debido a problemas internos, Python ejecutará un hilo tras otro. Este enfoque es útil si deseas ejecutar una tarea en segundo plano mientras haces que NVDA siga respondiendo.</td>
</tr>
<tr>
<td>Ejecutar algo periódicamente</td>
<td>wx.PyTimer o threading.Timer</td>
<td></td>
</tr>
<tr>
<td>Ocurrencia del recuento de texto en un documento</td>
<td>collections.Counter</td>
<td>Asegúrate de tener una lista de palabras de un archivo de texto antes de ejecutar una cuenta en él.</td>
</tr>
<tr>
<td>Crear una matriz dinámica</td>
<td>Objeto list</td>
<td>El objeto de lista de Python ([]) es una matriz dinámica.</td>
</tr>
<tr>
<td>Trabajar con matrices asociativas</td>
<td>Objeto dict</td>
<td>El objeto diccionario de Python ({}) es otro nombre para la matriz asociativa, a veces llamada mapa.</td>
</tr>
<tr>
<td>Abrir, analizar y guardar archivos de configuración</td>
<td>módulo config o módulo configobj</td>
<td></td>
</tr>
<tr>
<td>Quiero que mi código se ejecute más rápido y sin errores</td>
<td>¡No lo hagas a menos que sea necesario!</td>
<td>Citando a un conocido programador, "No optimices si no quieres tener dolores de cabeza".</td>
</tr>
<tr>
<td>Quiero liberar la versión 1.0 de mi código con todo incluido</td>
<td>¡Nunca lo hagas a menos que sepas por qué, sepas qué estás haciendo o lo especifique un contrato que hayas firmado!</td>
<td></td>
</tr>
<tr>
<td>Me gustaría traer una función de otro lector de pantalla a NVDA</td>
<td>Justifica por qué y planéalo adecuadamente</td>
<td></td>
</tr>
<tr>
<td>Quiero integrar funciones de mi complemento en el lector de pantalla NVDA</td>
<td>Envía una solicitud de cambios y prepárate para responder a las preguntas de los revisores</td>
<td>A veces, una o dos características de un complemento aterrizan en el lector de pantalla NVDA, pero después de pasar por un proceso de revisión en una solicitud de cambios. Para más información, mira las pautas de contribución de NV Access.</td>
</tr>
</tbody>
</table>
</body>
</html>